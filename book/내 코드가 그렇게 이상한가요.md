# 내 코드가 그렇게 이상한가요?

### 들어가며

책을 시작하기 전에 '원인을 알 수 없는 이유는 무엇일까요? 이는 이상적인 구조를 모르기 때문입니다.'라는 말이 인상 깊었다.
개발을 할때부터 이상적인 결과를 만드는 것은 힘들다고 생각하지만, 리팩터링은 다양한 경험과 지식을 통해 '이상적인 결과'를 만들어내는게 아닐까 라는 생각이 들었다.

# Chapter 1. 잘못된 구조의 문제 깨닫기

- 의미를 알 수 없는 네이밍
- 조건 분기의 중첩 (깊어지는 depth)
- 데이터 클래스
  - 아무런 기능도 하지 않는, 데이터를 갖기만 하는 클래스
  - 자칫하면 DTO나 VO랑 헷갈릴 수도 있을 것 같은 클래스이나, DTO는 '값 전달'을 위한 클래스이고 VO는 원시값을 감싸기 위해 주로 생성하는 객체이지만 비즈니스 로직을 가질 수 있다는 점에서 데이터 클래스와는 다르다.
  - 사실 이런 클래스를 만들 생각을 한 적 조차 없어서 이걸.. 왜 만들지? 라는 생각이 들기는 했다😅
  - 코드 중복, 변경사항 누락, 가독성 저하 등 많은 문제를 야기할 수 있음

# Chapter 2. 설계 첫걸음

- 의도를 분명히 전달할 수 있는 네이밍 짓기
- 변수를 계속 재할당해서 재사용하기보다는, 목적별로 분리하기
- 적절한 메서드 분리 (유사한 의미를 가진 로직들을 하나로 묶어 별도의 메서드로 추출하기)
- 관련된 데이터와 로직을 클래스로 모으기

# Chapter 3. 클래스 설계: 모든 것과 연결되는 설계 기반

- 생성자를 통한 생성 - 초기화되지 않은 상태 방지
- 계산 로직은 데이터를 가진 쪽에 구현하기 (응집도 높이기)
- 불변 변수를 통해 예상하지 못한 동작 막기 (final 키워드)
- 의미 없는 메서드 추가하지 않기

# Chapter 4. 불변 활용하기

- 재할당: 변수에 값을 다시 할당하는 것
  - 재할당이 가능한 변수는 언제 어떻게 변경되었는지 추적이 힘들다
  - 이를 방지하는 방법이 재할당이 불가능하도록 변수를 불변으로 만드는 것
- 변수 불변으로 만들기
  - final 키워드 붙이기
  - 코틀린에서는 아예 val 키워드 같이 불변 변수를 선언할 수 있게끔 만들어짐
  - 계속 재사용하는 인스턴스 객체인 경우(원시 타입이 아닌 참조 타입인 경우) 상태 변경이 가능한 메서드(ex: setter)를 통해 불변을 깨뜨릴 수 있음
- 뮤테이터: 상태를 변화시키는 메서드

# Chapter 5. 응집도

- 불필요하게 static 메서드를 남용하는 경우 응집도가 낮아질 수 있음
  - static의 적절한 예: 팩터리 메서드, util성 메서드
  - 꼭 필요한 경우가 아니라면 util성 메서드는 만들지 않는 것이 좋다
- 매개변수가 너무 많아져도 응집도가 떨어질 수 있음
- 묻지 말고 명령하기, tell don't ask
  - 값을 꺼내서 로직에 이용하지 말고 객체에게 물어라

# Chapter 6. 조건 분기

- 조건 분기가 중첩되면 가독성이 낮아진다
- 인터페이스, 전략패턴, 정책 패턴 등 사용 가능

# Chapter 7. 컬렉션: 중첩을 제거하는 구조화 테크닉

- 조기 continue, break
- 컬렉션을 캡슐화하여 컬렉션을 조작하는 로직을 한 클래스에서 처리 -> 응집도 증가
- 외부로 컬렉션을 그대로 return 시 외부에서 변경 가능함 -> unmodifiableList 등으로 변경 막기

<br/>

# Chapter 8. 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조

- 단일 책임 원칙을 기억하자
- DRY = Don't Repeat Yourself
  - 중복을 금지하라는 의미가 아니다
  - 같은 로직 비슷한 로직처럼 보여도, 개념이 다르면 중복을 허용해야 한다
- 상속을 하면 강한 결합이 생긴다 (인터페이스를 추천)
- 접근제어자를 최소화하라
- 한 클래스에 private 메서드가 많다 -> 책임이 너무 많은것은 아닌지 생각해보기
- 스마트 UI: 화면 표시하는 로직과 표시하지 않는 로직이 강하게 엮여있는 케이스?? 비즈니스 로직이 프런트에 존재하는 케이스?
- 갓 클래스: 하나의 클래스 내부에 수천~수만 줄의 로직을 담고 많은 책임을 담당하는 클래스

# Chapter 9. YAGNI 원칙

- 데드코드: 절대로 실행되지 않는 조건에 있는 코드 -> 불필요한 코드는 바로 제거하자
- YAGNI; You Aren't Gonna Need It; 지금 필요 없는 기능은 만들지 말자
- 매직넘버: 의미를 알기 힘든 숫자. -> 상수화하자
- 의미가 다른 값은 각각 다른 변수에 저장하는게 용이하다
- 영향 범위가 최소화되도록 설계하자 -> 변경이 가능한 전역 변수 같은건 코드 읽기가 어려워진다
- null이 들어갈 수 있다고 전제한 로직은 관리하기 힘들어진다
- 예외를 catch한 뒤 무시하면 원인 분석이 힘들어진다

# Chapter 10. 이름 설계

- 모든 정보가 한 클래스에 있으면 영향도가 너무 커진다
- 관심사에 따라 각각 클래스로 분할해야 한다
- 이름 설계하기
  - 최대한 구체적이고, 의미 범위가 좁고, 특화된 이름
  - 존재보단 목적 기반의 이름
  - 어떤 관심사를 가졌는지 분석하기
  - 소리 내어 이야기해보기
  - 대체 이름 생각해보기
  - 결합이 느슨하고 응집도가 높은 구조인지 검토하기
- 상황에 따라 의미가 달라질 수 있는 이름은 피해야함
- 이름을 봤을 때 위치가 부자연스러운 클래스 피하기
- 가능하면 메서드 이름은 동사 하나로

# Chapter 11. 주석

- 실제 코드와 내용이 다른 주석은 바로 제거하자
- 로직의 동작을 설명하는 주석은 번거롭다
  - 하지만 로직의 동작이 굉장히 복잡하다면 동작을 설명하는 편이 훨씬 간편하다고 생각
  - 자세한 주석을 작성하고 싶다면 팀과 잘 협의를 봐야할듯
- 주석으로 인해 메서드 이름을 대충 짓지 말자
  - 때로는 메서드 이름이 모호하거나 헷갈릴 수 있다고 생각... 명확한 이름이 제일 좋지만 ageOver20 이런 경우에는 20이상인가 20 초과인가 구분하는게 헷갈리지 않을까?
- Javadoc 같은 문서 주석을 잘 활용하자

# Chapter 12. 메서드

- 묻지 말고 명령하라
  - getter 같이 값을 가져온 다음, 해당 값을 이용해서 원하는 동작을 수행하기보다는 해당 동작을 수행하는 메서드를 만들자
- getter/setter로 도배된 클래스는 잘 캡슐화되었다라고 표현할 수 없다
- 매개변수를 메서드 내에서 직접 변경하기보다 불변을 유지하는게 좋다
- 플래그 매개변수 사용하지 않기
- null 전달하지 않기
  - 비슷한 맥락으로 Optional도 전달하면 안된다고 생각하는데, 이에 대해서는 포스팅을 작성한 적이 있다. > https://yeonyeon.tistory.com/224
- 매개변수는 최대한 적계 설계하기
- 최대한 null을 리턴하지 않게 만드는 것이 좋다
- 오류는 특정 코드나 값으로 리턴하기보다는 예외를 발생시키는 것이 좋다

# Chapter 13. 모델링: 클래스 설계의 토대

### 시스템, 모델, 모델링
- 시스템
  - : 수많은 구성 요소로 이루어진 집합체로서, 각 부분이 유기적으로 연결되어, 전체적으로 하나의 목적을 갖고 움직이는 것
  - ex: 사람은 두 다리로 번갈아 움직이며 이동하는 이족보행 시스템을 따름
  - 목적 달성을 위한 수단
- 모델
  - 시스템 구조를 설명하기 위해 단순한 상자로 도식화한 것
  - 시스템의 구성 요소 -> 특정 목적 달성을 위해 최소한의 필요 요소를 갖춘 것
- 모델링
  - 모델의 의도를 정의하고, 구조를 설계하는 것

### 모델링 tip
- '목적'별로 모델링하기
- 모델은 특정 대상이 아니라 목적 달성의 수단이다
  - 사용자, 상품 등의 어떤 사물이나 대상체 등을 모델로 잡으면 많은 정보를 담느라 데이터가 거대해진다
  - 특정 목적 달성과 관련된 부분만 추려 표현하자
  - ex: 사용자를 User로 표현하기보단, 사용자에 대한 특징을 Profile로, 로그인할 때 필요한 정보를 PersonalAccount 등으로 표현
- 단일 책임, 단일 목적
- 모델을 설계했다면, 해당 모델이 달성하려는 목적을 다시 확인해보자
  - 목적 이외의 요소가 들어있다면 수정 필요
- 모델 != 클래스
  - 모델 : 클래스 = N : 1에 가까움
  - 모델을 클래스와 코드로 정교화하며 어색한 것은 없는지, 필수적인 요소는 다 넣었는지 등을 피드백

### 기능성과 목적

- 기능성: 고객의 니즈를 만족하는 정도
- 숨어있는 목적을 잘 파악하자
  - 상품 구매를 하면 '상품 구입'과 '구입 품목'에 대해서만 생각해도 될 것 같지만, 법적인 요소도 고려해야함
  - 기능을 제대로 동작시키려면, 숨어 있는 목적까지 잘 파악해야함

# Chapter 14. 리팩터링: 기존의 코드를 성장시키는 기술

- 리팩터링: 실질적인 동작은 유지하면서, 구조만 정리하는 작업
- 중첩문을 제거한다, 의미 있는 단위로 로직을 정리한다(메서드 추출이라거나) 등
- 안전하게 리팩터링 하는 방법: 단위 테스트를 꼼꼼하게 작성한다
- 알 수 없는 레거시 리팩터링하기
  - 기존 코드를 이용해 input, output 목록을 정리한다
  - 위 과정을 통해 완벽한 사양을 밝히기는 어렵지만 전보다는 명확하게 만들 수 있음
  - 스크래치 리팩터링: 로직의 의미와 구조를 분석하기 위한 리팩터링
- 리팩터링 주의사항
  - 리팩터링과 기능 추가 동시에 하지 않기
  - 작은 단계로 실시하기

# Chapter 15. 설계의 의의와 설계를 대하는 방법

소프트웨어 품질과 관련된 특성
- 기능 적합성: 니즈를 만족하는가
- 성능 효율성
- 호환성
- 사용성: 사용자가 시스템을 만족하며 사용하는가
- 신뢰성
- 보안: 허용되지 않은 사용자로부터 보호
- 유지 보수성
- 이식성: 다른 실행 환경에 이식할 수 있는지

생산성 저하 요인
- 버그가 발생하기 쉬운 구조
- 가독성이 낮은 구조

코드 변경의 목적
- 소프트웨어의 가치를 높이기 위해
- 소프트웨어의 성장 가능성을 높이기 위해

메모
- 엔지니어에게 자산이란 기술력이다
- 레거시 코드는 발전을 막는다
- 이상적인 형태를 알아야 문제도 인식할 수 있다
  - 문제는 이상과 현실 차이에서 발생한다. 이상이 무엇인지 안다면 현실과 비교해가며 차근차근 해결할 수 있다
- 클래스를 작게 분할하는 것에 거부감을 갖는 사람들에게. 라이브러리 내부 구현이 어떻게 구현되어있는지 하나하나 신경쓰는 사람이 있나요? 코드에 대한 신뢰성이 낮기 때문에 분할을 불안해하는 것입니다.
  - 맥락과는 다른 이야기지만.. 최근에 이것 때문에 피봐서... 신경써야할 필요성을 느꼈다;;

# Chapter 16. 설계를 방해하는 개발 프로세스와의 싸움

> 개발 프로세스 자체가 레거시 코드의 발생 원인이 되기도 한다

### 커뮤니케이션이 부족하다
- 커뮤니케이션의 부족: 정보를 바라보는 관점이 다르다, 사이가 좋지 않다 등
- 콘웨이 법칙: 시스템 구조는 그것을 설계하는 조직의 구조를 닮아 간다
  - 3개의 조직으로 이루어진 곳이면 3개로 구성된 시스템이 만들어지기 쉽다
- 역콘웨이 법칙: 소프트웨어 구조를 먼저 설계하고, 이후 소프트웨어의 구조에 맞게 조직을 편성한다
- 심리적 안정성: 어떤 발언을 했을 때, 부끄럽거나 거절당하지 않을 것이라는 확신을 느낄 수 있는 심리 상태

### 설계가 제대로 이루어지지 못하다
- 빨리 끝내고싶다는 심리
- 클래스 설계와 구현 피드백 사이클 돌리기
  - 최소한 메모라도 클래스 다이어그램을 그리며 사양 변경하기
  - 이게 현실적으로 가능할까? 실제로는 비즈니스가 굉장히 복잡하게 되어있는데 클래스 다이어그램을 그리는데만 엄청 오래걸리지 않을까.. 대대적인 리팩터링을 각오하지 않고서는 가능할지 잘 모르겠다.
- 한번에 완벽하게 만들지 말고, 사이클을 돌리며 완성하기
- 너무 빠른 최적화; premeature optimization: 병목이 어디인지 모른 채 성능이 빠른 코드를 작성하려고만 하는 것
- 무작정 다수결로 설계 규칙을 만들지 말자
  - 설계 역량이 뛰어난 팀원이 중심이 되어 규칙을 만드는 것이 좋다
  - 모두의 의견을 설득하려다보면 수준이 낮은 쪽에 하향평준화될 수 있음 -> 말이 넘하네 ㅋㅋㅋ ㅠㅠㅠㅠ
  - 설계 규칙의 의도가 한번에 전달되기 힘듦 -> 리뷰와 스터디 등을 통해 의도를 계속 전달
  - 팀 구성원의 설계 역량이 어느 정도 성숙해지면 다시 설계 규칙에 대해 논의하기

### 구현
- 나쁜 구조가 눈에 띄면 조금씩이라도 좋으니 개선하는 습관을 기르자
  - 기존의 나쁜 코드를 보면 내 코드도 별로지만 저거보단 낫지..라는 생각을 하게 될 수 있음  
- 기존의 코드를 믿지 말고 냉정하게 파악하기
  - 히스토리를 완전히 파악하지 못한 사람에게는 기존 코드가 정말..... 일종의 규칙이나 기준선처럼 느껴지는데 어쩌면 좋을까
- 코딩 규칙 사용하기 - 코드 작성 방식 통일

### 리뷰
- 코드 리뷰 구조화
- 설계 시점에 리뷰 - 로직이 기능 요건을 만족하는 것도 중요하지만, 설계적 타당성을 중심으로 리뷰하는 것이 더 중요
- 공격적인 말 X. 존중과 예의
- 스케줄상 나중에 개편할 것으로 남긴 것은 이슈 등의 기능을 통해 꼭 나중의 과제로 남겨두기 - 잊혀지고 방치되기 쉽상
