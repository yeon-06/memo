# 프로그래머의 뇌
> 책 전반적인 후기: https://yeonyeon.tistory.com/295

### keywords

> 주요 용어들

- LTM; Long Term Memory
- STM; Short Term Memory
- 청크: 몇 개의 그룹으로 묶은 정보
- 작업 공간: 정보를 처리하는 것 (ex:123+456 연산을 생각한다면 +하는 과정)
- 정교화: 기억하고자 하는 내용을 기존 기억과 연관 지으며 생각하는 것
- 정신 모델: 두뇌의 외부에서 만들어지지 않은 모델. (ex: 하드 드라이브는 0과 1만을 가지고 있을 뿐이지만 우리는 파일 시스템을 생각할 때 폴더 안에 존재하는 파일 구조 따위를 생각한다.)
- 절차적 기억(=암시적 기억): 의식하지 않고 발휘되는 기술에 대한 기억
- 선언적 기억: 기억할 수 있는 사실이 있고 그 사실을 자신이 알고 있는 기억
  - 일화적 기억: 과거에 대한 기억
  - 의미적 기억: 어떤 의미, 개념, 사실에 대한 기억 (ex: 플래시 카드를 통해 기억한 기억)

### phrases

> 인상 깊었던 구절

- 특정한 주제에 대해 두뇌가 더 많은 정보를 저장하고 있다면 입력된 정보들을 효율적으로 청크로 묶는 것이 수월해진다는 사실을 살펴봤다.
- 오랫동안 학습한 만큼 더 오래 기억한다. 이것은 더 많은 시간을 학습해야 한다는 것을 의미하는 게 아니라 더 오랜 간격을 두고 학습해야 한다는 것을 의미한다.
- 당장 기억나지 않더라도 이런 기억하려는 노력은 기억을 강화하고 다음번에 기억해내는 데 도움이 될 것이다.
- 복잡한 소스코드를 읽을 때, 정신 모델의 구체적인 사례를 만들기보다는 정신 모델을 더 활용하기 위해 잠재적 정신 모델의 어휘를 더 많이 쌓아야 한다.
- 정신 모델에 대해 플래시카드를 사용할 수 있는 방법은 두 가지가 있다. 먼저 문법용 플래시 카드와 같은 방법으로 지식을 테스트하는 데 사용할 수 있다. (중략) 두 번재 방법은 이해가 안 되느 ㄴ어려운 코드를 읽을 때 사용하는 것이다. 플래시카드에 있는 정신 모델 중에 코드에 적용할 만한 것이 있는지 확인한다.
- 개념을 설명할 때는 그 설명을 듣는 사람이 친숙한 비유를 고르는 것이 중요하다.
- (오개념을 방지하는 방법) 첫째, 자신이 옳다고 확신하더라도 여전히 틀릴 수도 있다는 것을 아는 것이 중요하다. 열린 마음을 유지하는 것이 핵심이다. 둘째, 흔하게 발생하는 오개념에 대해 의도적으로 연구해봄으로써 그런 오개념에 빠지는 것을 방지할 수 있다. (중략) 마지막 조언은 같은 프로그래밍 언어를 같은 순서로 학습한 다른 프로그래머들에게 조언을 구하는 것이다.
- 캐멀 케이스 같은 문법 규칙부터 코드베이스 내의 일관성까지, 좋은 이름에 대한 다양한 관점이 있다.
- 언어적 안티패턴이 혼란스러울 수 있는 이유는 '잘못된 청킹'이 발생할 수 있기 때문이다.
- 작은 것들을 알아내는 데 시간을 많이 쓰지 않을수록 어려운 문제들을 더 쉽게 풀 수 있다.
- 특정 문제에 대해 생각할 때, 작업 기억 공간이 무엇을 구현할지 결정 한다. 그러나 작업 기억 공간이 결정을 내리기에 앞서 두 가지를 먼저 해야 한다. 첫 번째는 STM으로부터 문제의 상황에 대한 정보를 가져오는 것이다. 동시에 LTM은 관련 배경 지식을 검색한다. 코드베이스에 대한 관련 기억이 작업 기억 공간으로 전송된다. 문제 해결을 더 잘 이해하기 위해서는 LTM을 검색하는 이 두 번째 처리 과정을 탐구해야 한다.
- 문제 해결 능력을 높이는 두 가지 방법에 대해 알아보겠다. 첫 번째 기술은 자동화다. 어떤 기술을 여러 번 연습한 후에 아무 생각 없이 할 수 있을 정도가 되면 이 기술을 자동화했다고 한다. (중략) 두 번째 방법은 다른 사람들이 문제를 어떻게 해결했는지 의도적으로 연구하는 것이다. 
- 여러분이 가지고 있는 모든 인지 부하가 내재적 부하와 외재적 부하로 가득 차면, 본유적 부하를 위한 여지는 남아 있지 않게 된다. 즉 문제와 그 해결책을 기억할 수 없다. 힘든 코딩 작업을 마친 후 때때로 자신이 한 일을 기억하지 못하는 경우가 있을 것이다. 이것이 바로 이런 이유 때문이다. 두뇌가 해결책을 저장할 수 없을 정도로 몰입해 있었던 것이다.
- 대부분의 경우 서로 다른 차원 간의 트레이드오프가 이루어져야 한다. 한 차원을 개선하면 다른 차원이 감소할 수 있다.

### thinks

> 책을 읽으며 든 생각들

- 영단어 암기 카드가 플래시 카드라는 좀 더 있어보이는 표현도 있구나. 단순한 암기법이라 생각했는데 나름 누군가 연구해서 발견한 공부 방법이라는게 신기하다.
- 드라마틱한 학습 방법에 대한 이야기는 나오지 않는다. 어쨌든 나의 반복적인 노력과 학습을 통해 LTM을 늘리고, 보존시키는 것이 중요한 것 같다.
- 당연하게만 여겨왔던 개념이 새로운 언어로 다가온다. 옛날에는 이미 아는 지식에 대해 다시 학습하는 것에 대해 지겨움을 느꼈지만, 이제는 나의 표현을 풍부하게 해주고 보다 다양한 시각으로 볼 수 있게 해주는 것임을 안다.
- 이 책의 가장 큰 아쉬운 점은 용어가 너무 어렵다. 영어를 번역한 것이 오히려 더 어렵고 난해하게 느껴지는 경우도 많다.
- 생활 지식을 깨닫게 되는 점이 웃기다. (ㅋㅋㅋ) 고추는 씨앗 부분이 맵다, 고기의 표면을 태우면 육즙이 밀봉되는 것이 아니라 수분 손실이 더 커진다 같은? 잘 몰랐지만 누군가 말하면 그냥 그렇구나~ 할 법한 생활 지식으로 오개념에 대해 설명하니까 재밌었다.
- 처음 책을 반 정도 읽었을 때, 많은 사람들이 이 책이 그렇게까지 유명할만한 책인가? 싶었는데 남은 반절을 읽으면서 납득됐다. 프로그래밍에 있어 이론적으로 모호한 부분들에 대해 누군가 고민한 흔적을 엿볼 수 있던 시간이었다.
- 코드를 작성함에 있어 어느 정도 까지 자동화를 시킬지 고민해보는 것도 좋을 것 같다. 예를 들어 stream 을 사용하려고 한다고 가정할 때, 나는 IntelliJ와 함께라면 stream이 전혀 두렵지 않다. 문법을 하나하나 외우고 있지 않더라도 IntelliJ가 알아서 사용할 수 있는 메서드 목록을 띄워주고 심지어는 리팩터링할 부분을 제안해주기도 한다. 하지만 IntelliJ가 없다면? 조금 두려울지도 모른다. 책에서 나와있다시피 작은 것에 신경을 덜 쏟을수록 문제를 해결하기 쉬워지는데 요즘에는 이런 작은 것에 덜 신경쓰도록 만들어진 도구들이 정말 많다. 어디까지 의존할지 생각해보면 좋을듯 하다.
- 코딩을 하다 중간 작업을 멈출 때, 그리고 본래 작업까지 다시 되돌아오기 위해 메모를 남기는 것이 좋다. 유용한 팁이 될듯.
- 코드의 분산, 의존성 이런 것들에 대한 이야기도 나왔는데 이는 언어나 프레임워크의 특성에 따라 트레이드 오프되는 이야기가 많은 것 같다.
