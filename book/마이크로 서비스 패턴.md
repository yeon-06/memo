# 마이크로 서비스 패턴

### 시작하기 전에

본 책을 우테코 4기 크루들과 스터디를 통해 읽기로 하였다! OT를 진행하며 정한 규칙 등을 간단하게 메모한다.

- 1장부터 읽는다
- 주에 1장 단위로 읽는다
- 모임은 매주 일요일 11시 게더로 모인다

# 1장. 모놀리식 지옥에서 벗어나라

### 헥사고날 아키텍처; 육각형 아키텍처
- 비즈니스 로직은 각자가 도메인 객체 컬렉션인 모듈로 구성(ex 주문관리, 배달관리, 지불, ...)
- 외부 시스템과 연결하는 어댑터가 여럿 존재
  - 인바운드 어댑터: REST API, Web UI 어댑터 등 비즈니스 요청을 호출하여 처리
  - 아웃바운드 어댑터: 비즈니스 로직에서 DB나 클라우드 서비스를 호출하게 해줌
- 논리적으로 모듈화한 아키텍처이지만 애플리케이션은 WAR 파일 하나로 패키징

### 모놀리식 아키텍처

장점 
- 개발이 간단
- 애플리케이션의 변경이 쉬움
- 테스트가 쉬움
- 배포가 쉬움
- 확장이 쉬움

하지만 시간이 흐를수록 애플리케이션이 거대해지고 세분화되며 개발, 테스트, 배포, 확징이 어려워진다

### 확장 큐브
- X축 확장: 다중 인스턴스에 요청을 고르게 분산
- Z축 확장: 요청 속성별 라우팅 (=라우터가 요청 속성에 알맞은 인스턴스로 요청을 라우팅, 각 애플리케이션은 자신에게 배정된 사용자 하위 집합만 처리)
- Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해

### MSA의 특징
> MSA: 경계 컨텍스트가 있는, 느슨하게 결합된 엘리먼트로 구성된 서비스 지향 아키텍처
- 모듈성을 갖고 있다
- 서비스마다 DB가 따로 있다 -> 다른 서비스가 DB 락을 획득해 블로킹하는 일이 없다
- 서로 느슨하게 결합되어 있고, 오직 API를 통해서만 통신한다

#### SOA vs MSA
||SOA|MSA|
|---|---|---|
|서비스 간 통신|SOAP, WS 같은 무거운 프로토콜을 응용한 스마트 파이프 활용|메시지 브로커, REST, gRPC같은 가벼운 프로토콜을 이용해 덤 파이프 활용|
|데이터|전역 데이터 모델 및 공유 DB|서비스 개별 데이터 모델 및 DB|

#### MSA 장점
- 크고 복잡한 애플리케이션의 지속적 전달, 배포가 가능
  - 지속적 전달 = continuous delivery: 새 기능, 구성 변경, 버그 조치 등 여러 변경사항을 프로덕션사용자에게 직접 안전하고 신속하게, 일정한 수준으로 계속 전달하는 능력 (sw를 언제든 릴리즈할 수 있는 능력)
  - 지속적 배포: 릴리즈 가능한 코드를 프로덕션에 자동 배포하는 것. 하루에도 여러 차례 배포를 수행하면서도 중단 사고는 거의 없고, 사고가 발생해도 신속하게 복구가 가능하다.
- 서비스가 작아 관리가 용이
- 서비스를 독립적으로 배포/확장할 수 있음 (=독립적으로 X/Z축 확장이 가능)
- 결함 격리가 잘됨
- 신기술 시험/도입이 쉬움

#### MSA 단점
- MSA에 맞게 시스템을 여러 서비스로 분해하는 구체적으로 정립된 알고리즘이 따로 없음
- 분산 시스템으로 인한 복잡성 -> 개발, 테스트, 배포가 어려움
- 여러 서비스에 걸친 기능을 배포할 때 복잡도 up
- MSA 도입 시점을 알기 어려움

#### MSA에 대한 오해

- MSA를 적용한다고 모든 아키텍처 문제가 해결되는 것은 아니다
  - 모든건 트레이드 오프

### 패턴
- 패턴: 특정한 상황에서 발생한 문제에 대해 재사용 가능한 해법
- 패턴 언어: 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합
- 패턴은 자신이 적용되는 맥락을 반드시 기술해야 한다
  - 언제는 통하지만 어떨 때는 안 통하는, 이런 생각이 기술을 더 나은 방법으로 발전하게 만듦

#### 상용 패턴의 구조
- 강제 조항; forces: 문제 해결을 위해 반드시 처리해야 할 이슈
  - 모든 조항을 충족시키는 것은 힘든 일 -> 우선순위를 정해야 한다
- 결과 맥락; result context: 패턴 적용 결과
  - 패턴을 적용한 결과를 장점, 단점, 이슈(패턴 적용 시 발생한 새로운 문제점)으로 기술하는 것
- 연관 패턴; related patterns: 한 패턴과 다른 패턴의 관계를 기술
  -  패턴 관계는 5가지 존재

#### 패턴 관계
-  선행자; predecessor: 이 패턴을 필요하게 만든 선행 패턴. (ex: MSA 패턴은 모놀리식 아키텍처 패턴을 제외한 나머지 패턴들의 선행자이다.)
-  후행자; successor: 이 패턴으로 야기되는 이슈를 해결하는 패턴.
-  대안; alternative: 대체재 역할의 패턴.
-  일반화; generalization: 문제를 해결하는 패턴.
-  세분화; specialization: 패턴을 더 세부적으로 나타낸 형태.

#### 패턴 그룹
- 패턴 언어는 여러 패턴을 모아둔 집합이다.
- 패턴 언어 내에서도 여러개의 패턴 그룹으로 나눌 수 있다. (아래 예제는 MSA 패턴 언어를 고수준에서 바라본 그림)
![image](https://github.com/yeon-06/memo/assets/53105735/8bbfec7e-463e-4380-8789-91fd55531ae1)
- 인프라 패턴: 개발 영역 밖의 인프라 문제를 해결
- 애플리케이션 인프라: 개발에도 영향을 미치는 인프라 문제 해결
- 애플리케이션 패턴: 개발자가 맞닥뜨리는 문제 해결

#### 애플리케이션을 여러 서비스로 분해하는 패턴
> 패턴에 대한 것들은 책에서 그림을 직접 참고하길 바람
- 통신 패턴
  - MSA로 구축한 애플리케이션은 기본적으로 분산 시스템이기 때문에 IPC(프로세스 간 통신)이 중요
  - 통신 스타일: 사용하는 IPC 종류
  - 디스커버리: 클라이언트는 서비스 인스턴스의 IP주소를 어떻게 가져오는가
  - 신뢰성: 서비스 불능 시 서비스 간 통신의 신뢰성 보장은 어떻게?
  - 트랜잭셔널 메시징: DB 트랜잭션에 메시지 송신 및 이벤트 발행하는 행위를 어떻게 통합할 것인가
  - 외부 API: 클라이언트는 서비스와 어떻게 통신하는가
- 데이터 일관성 패턴: 서비스마다 다른 DB를 사용하기 때문에 데이터 일관성을 신경써야 함
- 데이터 쿼리 패턴: 각 다른 DB로 인해 데이터를 조인하는 쿼리도 문제가 됨.
  - API 조합 패턴: 하나 이상의 서비스를 호출해 그 결과를 조합
  - CQRS; Command Query Responsibility Segregation: 하나 이상의 데이터 replica를 유지해 쉽게 쿼리하는 방식
- 서비스 배포 패턴
- 관측성 패턴: 애플리케이션 동작을 이해하고 요청 실패, 높은 지연 시간 등의 문제를 진단/조치
  - 헬스 체크 API
  - 로그 수집
  - 분산 추적: 각 외부 요청마다 id를 부여해 서비스를 통과하는 과정 추적
  - 예외 추적
  - 애플리케이션 지표: 카운트, 게이지 등의 지표(metric)을 측정해 지표 서버에 표출
  - 감사 로깅: 사용자가 한 일을 기록
- 서비스 테스트 자동화 패턴
  - 여러 서비스가 조화롭게 잘 작동되는지 테스트하는 일이 중요
  - e2e 테스트 같은 느리고, 복잡한 테스트는 피하는 것이 좋음
  - consumer-driven contract test: 클라이언트가 의도한 대로 서비스가 동작하는지 확인
  - consumer-side contract test: 클라이언트-서비스 상호 통신 가능한지 확인
  - service component test: 서비스를 따로 테스트
- 횡단 관심사 패턴: 공통 관심사를 처리하는 프레임워크에서 microservice chassis 패턴을 적용해 서비스를 구축
- 보안 패턴

### 프로세스, 조직, 아키텍처
![image](https://github.com/yeon-06/memo/assets/53105735/b30ca158-f07a-42f6-bcb4-54f4381924eb)

#### 조직

- 거대한 팀보다는 작은 여러 팀의 움직임이 훨씬 빠르다
- 콘웨이 법칙: 시스템을 설계하는 조직은 그들이 소통하는 구조를 그대로 옮겨 놓은 듯한 결과물을 낼 수밖에 없는 한계가 있다.
- 이 법칙을 역으로 이용해 조직의 구조가 MSA에 반영되도록 설계해야 한다.
