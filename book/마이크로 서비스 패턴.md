# 마이크로 서비스 패턴

### 시작하기 전에

본 책을 우테코 4기 크루들과 스터디를 통해 읽기로 하였다! OT를 진행하며 정한 규칙 등을 간단하게 메모한다.

- 1장부터 읽는다
- 주에 1장 단위로 읽는다
- 모임은 매주 일요일 11시 게더로 모인다

# 1장. 모놀리식 지옥에서 벗어나라

### 헥사고날 아키텍처; 육각형 아키텍처
- 비즈니스 로직은 각자가 도메인 객체 컬렉션인 모듈로 구성(ex 주문관리, 배달관리, 지불, ...)
- 외부 시스템과 연결하는 어댑터가 여럿 존재
  - 인바운드 어댑터: REST API, Web UI 어댑터 등 비즈니스 요청을 호출하여 처리
  - 아웃바운드 어댑터: 비즈니스 로직에서 DB나 클라우드 서비스를 호출하게 해줌
- 논리적으로 모듈화한 아키텍처이지만 애플리케이션은 WAR 파일 하나로 패키징

### 모놀리식 아키텍처

장점 
- 개발이 간단
- 애플리케이션의 변경이 쉬움
- 테스트가 쉬움
- 배포가 쉬움
- 확장이 쉬움

하지만 시간이 흐를수록 애플리케이션이 거대해지고 세분화되며 개발, 테스트, 배포, 확징이 어려워진다

### 확장 큐브
- X축 확장: 다중 인스턴스에 요청을 고르게 분산
- Z축 확장: 요청 속성별 라우팅 (=라우터가 요청 속성에 알맞은 인스턴스로 요청을 라우팅, 각 애플리케이션은 자신에게 배정된 사용자 하위 집합만 처리)
- Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해

### MSA의 특징
> MSA: 경계 컨텍스트가 있는, 느슨하게 결합된 엘리먼트로 구성된 서비스 지향 아키텍처
- 모듈성을 갖고 있다
- 서비스마다 DB가 따로 있다 -> 다른 서비스가 DB 락을 획득해 블로킹하는 일이 없다
- 서로 느슨하게 결합되어 있고, 오직 API를 통해서만 통신한다

#### SOA vs MSA
||SOA|MSA|
|---|---|---|
|서비스 간 통신|SOAP, WS 같은 무거운 프로토콜을 응용한 스마트 파이프 활용|메시지 브로커, REST, gRPC같은 가벼운 프로토콜을 이용해 덤 파이프 활용|
|데이터|전역 데이터 모델 및 공유 DB|서비스 개별 데이터 모델 및 DB|

#### MSA 장점
- 크고 복잡한 애플리케이션의 지속적 전달, 배포가 가능
  - 지속적 전달 = continuous delivery: 새 기능, 구성 변경, 버그 조치 등 여러 변경사항을 프로덕션사용자에게 직접 안전하고 신속하게, 일정한 수준으로 계속 전달하는 능력 (sw를 언제든 릴리즈할 수 있는 능력)
  - 지속적 배포: 릴리즈 가능한 코드를 프로덕션에 자동 배포하는 것. 하루에도 여러 차례 배포를 수행하면서도 중단 사고는 거의 없고, 사고가 발생해도 신속하게 복구가 가능하다.
- 서비스가 작아 관리가 용이
- 서비스를 독립적으로 배포/확장할 수 있음 (=독립적으로 X/Z축 확장이 가능)
- 결함 격리가 잘됨
- 신기술 시험/도입이 쉬움

#### MSA 단점
- MSA에 맞게 시스템을 여러 서비스로 분해하는 구체적으로 정립된 알고리즘이 따로 없음
- 분산 시스템으로 인한 복잡성 -> 개발, 테스트, 배포가 어려움
- 여러 서비스에 걸친 기능을 배포할 때 복잡도 up
- MSA 도입 시점을 알기 어려움

#### MSA에 대한 오해

- MSA를 적용한다고 모든 아키텍처 문제가 해결되는 것은 아니다
  - 모든건 트레이드 오프

### 패턴
- 패턴: 특정한 상황에서 발생한 문제에 대해 재사용 가능한 해법
- 패턴 언어: 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합
- 패턴은 자신이 적용되는 맥락을 반드시 기술해야 한다
  - 언제는 통하지만 어떨 때는 안 통하는, 이런 생각이 기술을 더 나은 방법으로 발전하게 만듦

#### 상용 패턴의 구조
- 강제 조항; forces: 문제 해결을 위해 반드시 처리해야 할 이슈
  - 모든 조항을 충족시키는 것은 힘든 일 -> 우선순위를 정해야 한다
- 결과 맥락; result context: 패턴 적용 결과
  - 패턴을 적용한 결과를 장점, 단점, 이슈(패턴 적용 시 발생한 새로운 문제점)으로 기술하는 것
- 연관 패턴; related patterns: 한 패턴과 다른 패턴의 관계를 기술
  -  패턴 관계는 5가지 존재

#### 패턴 관계
-  선행자; predecessor: 이 패턴을 필요하게 만든 선행 패턴. (ex: MSA 패턴은 모놀리식 아키텍처 패턴을 제외한 나머지 패턴들의 선행자이다.)
-  후행자; successor: 이 패턴으로 야기되는 이슈를 해결하는 패턴.
-  대안; alternative: 대체재 역할의 패턴.
-  일반화; generalization: 문제를 해결하는 패턴.
-  세분화; specialization: 패턴을 더 세부적으로 나타낸 형태.

#### 패턴 그룹
- 패턴 언어는 여러 패턴을 모아둔 집합이다.
- 패턴 언어 내에서도 여러개의 패턴 그룹으로 나눌 수 있다. (아래 예제는 MSA 패턴 언어를 고수준에서 바라본 그림)
![image](https://github.com/yeon-06/memo/assets/53105735/8bbfec7e-463e-4380-8789-91fd55531ae1)
- 인프라 패턴: 개발 영역 밖의 인프라 문제를 해결
- 애플리케이션 인프라: 개발에도 영향을 미치는 인프라 문제 해결
- 애플리케이션 패턴: 개발자가 맞닥뜨리는 문제 해결

#### 애플리케이션을 여러 서비스로 분해하는 패턴
> 패턴에 대한 것들은 책에서 그림을 직접 참고하길 바람
- 통신 패턴
  - MSA로 구축한 애플리케이션은 기본적으로 분산 시스템이기 때문에 IPC(프로세스 간 통신)이 중요
  - 통신 스타일: 사용하는 IPC 종류
  - 디스커버리: 클라이언트는 서비스 인스턴스의 IP주소를 어떻게 가져오는가
  - 신뢰성: 서비스 불능 시 서비스 간 통신의 신뢰성 보장은 어떻게?
  - 트랜잭셔널 메시징: DB 트랜잭션에 메시지 송신 및 이벤트 발행하는 행위를 어떻게 통합할 것인가
  - 외부 API: 클라이언트는 서비스와 어떻게 통신하는가
- 데이터 일관성 패턴: 서비스마다 다른 DB를 사용하기 때문에 데이터 일관성을 신경써야 함
- 데이터 쿼리 패턴: 각 다른 DB로 인해 데이터를 조인하는 쿼리도 문제가 됨.
  - API 조합 패턴: 하나 이상의 서비스를 호출해 그 결과를 조합
  - CQRS; Command Query Responsibility Segregation: 하나 이상의 데이터 replica를 유지해 쉽게 쿼리하는 방식
- 서비스 배포 패턴
- 관측성 패턴: 애플리케이션 동작을 이해하고 요청 실패, 높은 지연 시간 등의 문제를 진단/조치
  - 헬스 체크 API
  - 로그 수집
  - 분산 추적: 각 외부 요청마다 id를 부여해 서비스를 통과하는 과정 추적
  - 예외 추적
  - 애플리케이션 지표: 카운트, 게이지 등의 지표(metric)을 측정해 지표 서버에 표출
  - 감사 로깅: 사용자가 한 일을 기록
- 서비스 테스트 자동화 패턴
  - 여러 서비스가 조화롭게 잘 작동되는지 테스트하는 일이 중요
  - e2e 테스트 같은 느리고, 복잡한 테스트는 피하는 것이 좋음
  - consumer-driven contract test: 클라이언트가 의도한 대로 서비스가 동작하는지 확인
  - consumer-side contract test: 클라이언트-서비스 상호 통신 가능한지 확인
  - service component test: 서비스를 따로 테스트
- 횡단 관심사 패턴: 공통 관심사를 처리하는 프레임워크에서 microservice chassis 패턴을 적용해 서비스를 구축
- 보안 패턴

### 프로세스, 조직, 아키텍처
![image](https://github.com/yeon-06/memo/assets/53105735/b30ca158-f07a-42f6-bcb4-54f4381924eb)

#### 조직

- 거대한 팀보다는 작은 여러 팀의 움직임이 훨씬 빠르다
- 콘웨이 법칙: 시스템을 설계하는 조직은 그들이 소통하는 구조를 그대로 옮겨 놓은 듯한 결과물을 낼 수밖에 없는 한계가 있다.
- 이 법칙을 역으로 이용해 조직의 구조가 MSA에 반영되도록 설계해야 한다.

# 2장. 분해 전략

### 소프트웨어 아키텍처
- : 구성 요소 및 그들 간의 의존관계로 엮인 고수준의 구조물
- 애플리케이션 아키텍처는 다차원적 -> 기술하는 방법도 다양
- : 소프트웨어 element와 그들 간의 관계, 그리고 이 둘의 property로 구성된 시스템을 추론하는 데 필요한 구조의 집합이다. - 소프트웨어 아키텍처 문서화, Bass
- 애플리케이션 아키텍처는 여러 파트(엘리먼트)로의 분해와 이런 파트 간의 관계 (연관성)

### 4+1 뷰 모델

- 논리 뷰: 개발자가 작성한 소프트웨어 엘리먼트. 클래스, 패키지, 클래스와 패키지의 관계
- 구현 뷰: 빌드 시스템의 결과물.
- 프로세스 뷰: 런타임 컴포넌트
- 배포 뷰: 프로세스가 머신에 매핑되는 방법
- 시나리오: 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술

### 아키텍처 스타일
- 체계적인 조직의 관점에서 시스템 군을 정의
- 인스턴스에서 사용 가능한 컴포넌트와 커넥터, vocabulary, 이들을 조합할 수 있는 제약 조건을 결정

#### 계층화 아키텍처
- 계층마다 명확히 정의된 역할을 분담
- 계층 간 디펜던시는 아키텍처로 제한
- 3계층 아키텍처: 표현+비즈니스로직+영속화 계층

#### 육각형 아키텍처
- 포트: 비즈니스 로직이 자신의 외부 세계와 상호 작용하는 방법이 정의된 작업 (ex: java - interface)
  - 인바운드 포트: 비즈니스 로직이 표출된 API. 외부 애플리케이션은 이 API를 통해 비즈니스 로직 호출
  - 아웃바운드 포트: 비즈니스 로직이 외부 시스템을 호출하는 방법
- 표현 계층 대신 인바운드 어댑터를, 영속화 계층 대신 아웃바운드 어댑터 적용

#### 모놀리식 아키텍처
- 구현 뷰를 단일 컴포넌트로 구성한 아키텍처 스타일

#### 마이크로서비스 아키텍처
- 구현 뷰를 다수의 컴포넌트로 구성
- 각 서비스는 자체 논리 뷰 아키텍처를 가짐
  - 서비스: 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트
- 커넥터: 이런 서비스가 서로 협동할 수 있게 해주는 통신 프로토콜
- 핵심 제약 조건: 서비스를 느슨하게 결합하자!

> **느슨한 결합**
> 서비스는 구현 코드를 감싼 API를 통해서만 상호작용 -> 클라이언트에 영향 끼치지 않고 서비스 내부 구조 변경 가능
> DB 테이블 미공유 -> 런타임 격리 향상. 일관성 유지가 복잡해짐.

### 아키텍처 정의하기
1. 애플리케이션 요건을 핵심 요청으로 추출
  - 도메인 모델은 주로 사용자 스토리의 명사에서 도출
2. 어떻게 여러 서비스로 분해할지 결정
  - 비즈니스 능력 패턴별 분해
    - 비즈니스 능력: 비즈니스가 가치를 생산하기 위해 하는 일
    - 서비스를 거의 변하지 않는 비즈니스 능력에 따라 구성하면 비교적 안정적인 아키텍처를 구축할 수 있다
  - 하위 도메인 패턴별 분해
    - DDD: 객체 지향 도메인 모델 중심의 복잡한 소프트웨어 애플리케이션을 구축하는 방법
    - 도메인을 구성하는 각 하위 도메인마다 도메인 모델을 따로 정의하면 비즈니스 능력과 같은 방법으로 식별하므로 비즈니스 능력과 유사한 하위 도메인이 도출됨
3. 서비스별로 API 정의
  - 서비스 이벤트는 주로 타 서비스와 협동하기 위해 발생
  - 서비스 API를 정의하려면 우선 각각의 시스템 작업을 서비스로 매핑하고, 그 시스템 작업을 구현하려면 어느 서비스가 서로 협동해야 할지 파악해야 함

> **분해 지침**  
> 단일 책임 원칙: 클래스는 오직 하나의 변경 사유를 가져야 한다  
> 공동 폐쇄 원칙: 패키지 클래스들은 동일한 융형의 변경엥 대해 닫혀 있어야 한다. 패키지에 영향을 주는 변경은 그 패키지에 속한 모든 클래스에 영향을 끼친다.

### 분해 과정의 장애물
- 네트워크 지연
- 잦은 동기 통신으로 인해 낮아지는 가용성
- 데이터 일관성
- 일관된 데이터 뷰 확보
- 애플리케이션 곳곳의 만능 클래스

# 3장. 프로세스 간 통신
### 상호 작용 스타일
- 일대일: 각 클라이언트 요청은 한 서비스가 처리
- 일대다: 각 클라이언트 요청을 여러 서비스가 협동하여 처리
- 동기: 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹 가능
- 비동기: 클라이언트가 블로킹 X

#### 일대일 상호 작용
- 요청/응답: 서비스에 요청하고 응답을 기다린다
- 비동기 요청/응답: 서비스에 요청하고 서비스는 비동기적으로 응답
- 단방향 알림: 서비스의 응답 X

#### 일대다 상호 작용
- 발행/구독: 클라이언트는 알림 메시지 발행, 서비스가 메시지 소비
- 발행/비동기 응답: 클라이언트는 요청 메시지 발행, 주어진 기간 동안 서비스가 응답하길 기다림

### API 변경
- 시맨틱 버저닝
  - MAJOR: 하위 호환 X 변경
  - MINOR: 하위 호환 O 변경
  - PATCH: 하위 호환 O 오류 수정
- 견고성 원칙: 당신이 하는 일은 보수적으로, 다른 사람이 하는 일은 관대하게 바라보라

### 메시지 포맷
- 텍스트 메시지 포맷
  - JSON, XML
  - 사람이 읽을 수 있고 자기 서술적
  - 메시지가 길다
- 이진 메시지 포맷
  - 프로토콜 버퍼, 아브로

### RPI
- : 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC

#### REST
- 동기 RPI 패턴
- HTTP로 소통하는 IPC
- 장점
  - 단순, 익숙
  - 간편한 테스트 가능 (포스트맨, curl, ..)
  - 요청/응답 스타일의 통신을 직접 지원
  - 방화벽 친화적
  - 중간 브로커 필요 X
- 단점
  - 요청/응답 스타일의 통신만 지원
  - 가용성 down -클라이언트/서비스 둘 다 실행중이어야 통신 가능
  - 서비스 인스턴스의 위치를 클라이언트가 알고있어야 함
  - 요청 한 번으로 여러 리소스를 가져오기 어려움
  - 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려움

#### gRPC
- google Remote Procedure Call
- 동기 RPI 패턴
- 이진 메시지 기반의 프로토콜
- 프로토콜 버퍼 메시지 포맷 사용
  - 프로토콜 버퍼: 간결하고 효율적인 이진 포맷
  - 메시지 수신자는 자신이 필요한 필드만 추출하고, 모르는 필드 건너뛰기 가능
- 장점
  - 업뎃 작업이 포함한 API 설계가 쉬움
  - 큰 메시지 교환 시 효율적
  - 양방향 스트리밍
  - 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크
- 단점
  - 자바스크립트 클라이언트가 하는 일이 REST/JSON 기반 API보다 많음
  - 구형 방화벽은 HTTP/2 미지원
  
### RPI 프록시 설계
- 네트워크 타임아웃: 응답 대기는 무한정 블로킹하는게 아니라 타임아웃 설정
- 미처리 요청 개수 제한
- circuit breaker 패턴: 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시

### 불능 서비스 복구
- 그때그때 상황에 맞게 판단
- 클라이언트에 에러 반환
- 부분 실패 시 미리 정해진 기본값이나 캐시된 응답 등 대체 값을 반환
- 캐시된 버전의 데이터 또는 에러 반환

### 서비스 디스커버리
- 서비스를 호출하는 코드는 서비스 인스턴스의 네트워크 위치를 알아야 요청 가능
- 클라우드 기반 MSA는 네트워크 위치가 동적이라 식별하는 일이 간단하지 않음
- : 애플리케이션 서비스 인스턴스의 네트워크 위치를 DB화한 서비스 레지스트리

### 메시지 상호작용 스타일
- 단방향 알림
- 발행/구독
- 발행/비동기 응답: 클라이언트 -> 발행/구독 채널에 발행. 컨슈머: CorrelationId가 포함된 응답 ㅔㅁ시지를 지정된 응답 채널에 사용. 클ㄹ라이언트는 CorrelationId로 응답을 취합해 응답 메시지와 요청 맞춤

### 중복 메시지 처리
- 메시지 브로커는 보통 1번 이상 메시지를 전달하겠다고 약속
- 멱등한 메시지 핸들러 작성: 반복 호출해도 부수 효과가 없는 멱등한 로직 작성
- 메시지 추적하고 중복을 솎아내기

### 동기 상호 작용 제거 
- 동기 통신은 가용성이 저하됨
- 데이터 복제
  - 요청 처리에 필요한 데이터의 레플리카를 유지
