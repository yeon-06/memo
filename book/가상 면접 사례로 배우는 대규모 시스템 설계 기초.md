# 가상 면접 사례로 배우는 대규모 시스템 설계 기초

## Ch01. 사용자 수에 따른 규모 확장성

### 단일 서버
* 가장 단순한 형태의 서버
* 모든 구성 요소가 단 하나의 서버에 담긴 형태

### 서버의 성능 개선하기
* 수직적 규모 확장 (스케일업): 서버에 고사양 자원(ex: CPU, RAM)을 추가하는 행위
* 수평적 규모 확장 (스케일아웃): 더 많은 서버를 추가하는 행위

### 로드밸랜서
* 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할
* 웹 서버 하나가 다운되어도 다른 웹 서버에 트래픽을 전송하면 된다.

### 데이터베이스 다중화
* master-slave 관계 설정
* 데이터 원본은 주(master) 서버, 사본은 부(slave) 서버
* 주 서버는 쓰기 연산 지원을 지원하고 부 서버는 읽기 연산만 지원한다.
* 대부분의 애플리케이션은 쓰기보다는 읽기 연산 비중이 훨씬 높기 때문에.

### 캐시
* 값비싼 연산 결과나 자주 쓰는 데이터를 메모리 안에 두고 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소
* 고려사항
  * 갱신이 자주 일어나는 데이터인가
  * 어떤 데이터를 캐시에 둬야하는가
  * 어떻게, 언제 만료되는가
  * 일관성은 어떻게 유지되는가
  * 장애에 어떻게 대처할 것인가
  * 캐시 메모리의 크기는 어떻게 잡을 것인가?
  * (캐시가 꽉 찬 경우) 데이터 방출을 어떻게 할 것인가?

### CDN; 컨텐츠 전송 네트워크
* 정적 컨텐츠를 전송하는데 쓰는 지리적으로 분산된 서버의 네트워크
* 요청을 보내는 클라이언트가 한국에 있다면 LA에 있는 원본서버보다 서울에 있는 CDN 서버에 접근해서 데이터를 가져오는 것이 훨씬 빠르다
* 고려사항
  * 비용
  * 적절한 만료 시한 설정
  * 장애 시 대처 방안
  * 컨텐츠 무효화 방법

### 무상태; stateless
* 웹 계층을 수평적으로 확장할 때 상태 정보(ex:사용자 세션)를 고려해야함
* 특정 서버에 세션 데이터를 저장하고 있으면 클라이언트는 해당 서버에만 접근해야함 (고정 세션, sticky session)
* 상태가 없는 무상태 아키텍쳐를 고려해야 함

### 메시지 큐
* 메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트
* 생산자 또는 발행자는 메시지를 만들어 메시지 큐에 발행(publish)
* 소비자 또는 구독자는 해당 메시지로 적절한 동작 수행
* 서비스/서버 간의 결합을 느슨하게 함

#### 데이터베이스 규모 확장
* 수직적 확장; 스케일 업
  * 더 좋은, 고성능의 자원으로 업그레이드
* 수평적 확장; 샤딩
  * 더 많은 서버 추가
  * 샤딩 전략을 구현할 때 중요한 것은 샤딩키(=파티션 키)
  * 새로운 문제 발생
    * 재샤딩: 데이터가 너무 많아져서 하나의 샤드로 감당이 힘들때, 분포가 균등하지 못할 때
    * 유명인사(핫스팟키) 문제: 특정 샤드에 질의가 집중될 때
    * 조인과 비정규화: 여러 샤드에 걸친 데이터를 조인하기 어려워질 때 -> 비정규화를 통해 하나의 테이블에서 질의가 수행되도록 하면 됨

## ch02. 개략적인 규모 측정
> : 보편적으로 통용되는 성능 수치상에서 사고 실험을 행하여 추정치를 계산하는 행위. 
> 어떤 설계가 요구사항에 부합할 것인지 보기 위한 것

- 메모리는 빠르지만 디스크는 아직 느림
- 디스크 탐색은 피하는 것이 좋음
- 단순한 압축 알고리즘은 빠름
- 데이터를 인터넷으로 전송하기 전에 가능하면 압축하라.

## ch03. 시스템 설계 면접 공략법

- 빠르게 대답하는 것은 그닥 메리트가 없다
- 질문을 통해 요구사항과 내 가정을 확인하라
- 면접관과 소통하라
- 가능하다면 여러 해법을 함께 제시하라

## ch04. 처리율 제한 장치의 설계

### 처리율 제한 장치(rate limiter)
- : 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하기 위한 장치
- ex) 같은 IP 주소로는 하루에 계정을 3개까지만 만들 수 있다, 사용자는 초당 2회 이상의 새 글을 올릴 수 없다
- 장점
  - DoS 공격에 의한 자원 고갈 방지
  - 비용 절감 (요청을 덜 처리할 수 있으니)
  - 서버 과부하 방지
- 제한 장치의 위치
  - 클라이언트: 클라이언트 요청은 쉽게 위변조가 가능해 통제가 어려울 수 있음
  - API 서버
  - 미들웨어: 클라이언트-API서버 사이에서 API 서버로 가는 요청을 통제
- 어디다 두는 것이 좋을까?
  - 정답은 없다.
  - 사용중인 기술 스택, 설계, 할당 가능한 리소스량에 따라 다름
  - ex: 처리율 제한 장치를 직접 만들기 위한 인력이 없다면 상용 API 게이트웨이를 쓰는 것이 낫다
- 요청이 한도 제한에 걸리면 HTTP 429(too many requests)를 반환하도록 만들 수 있음

### 처리율 제한 알고리즘
> 처리율 제한을 실현하는 알고리즘  
> 자세한 설명은 책을 참고하길 바라며 이 글에서는 생략.

- 토큰 버킷
- 누출 버킷
- 고정 윈도 카운터
- 이동 윈도 로그
- 이동 윈도 카운터

### 분산 환경에서의 처리율 제한 장치
> 여러 대의 서버와 병렬 스레드를 지원하는 시스템을 확장하려면 두 가지 문제를 풀어야함

- 경쟁 조건; race condition
  - 락, 루아 스크립트, Redis - 정렬 집합 등을 통해 해결 가능
- 동기화; synchronization
  - sticky session, 중앙 집중형 데이터 저장소(ex:Redis) 사용 등을 통해 해결 가능

### 더 공부해볼만한 것

- hard / soft 처리율 제한
  - 경성(hard): 요청의 개수는 임계치를 절대 넘을 수 없음
  - 연성(soft): 요청 개수는 잠시동안만 임계치를 넘어설 수 있음
- 다양한 계층에서의 처리율 제한
  - 위 내용은 애플리케이션 계층에서의 처리율 제한임
  - OSI 3계층에서의 Iptables 사용 등 다른 계층에서도 처리율 제한이 가능
- 처리율 제한을 회피하는 방법 (최선의 클라이언트 설계는 무엇인가)
  - 클라이언트 측 캐시를 통해 API 호출 횟수 줄이기
  - 처리율 제한의 임계치를 이해하기 (단기간 많은 메시지 보내지 않도록 하기)
  - 예외/에러 처리하는 코드 도입
  - 재시도 로직을 구현할 때는 충분한 백오프 시간 두기

## ch05. 안정 해시 설계

- 수평적 규모 확장성을 달성하기 위해서는 요청/데이터를 서버에 **균등**하게 나누는 것이 중요
- 안정 해시는 이 목표를 위해 보편적으로 사용하는 기술

### 해시 키 재배치 문제

3개의 서버에 key 0...5를 배치해보자  
해시 함수를 통해 %3의 결과에 따라 재배치를 한다.

- server0: key0, key3
- server1: key1, key4
- server2: key2, key5

만약 server1에 장애가 발생한다면? 키의 재분배가 필요하다

- server0: key0, key2, key4
- server2: key1, key3, key5

server1에 보관되었던 키를 포함해 많은 키들이 재배치 되었다.  
안정 해시는 이 문제를 효과적으로 해결하기 위한 기술이다.

### 안정 해시; consistent hash

- s는 서버이고, k는 키이다.
- 원 위에 s를 균등 분포 해시 함수를 통해 특정 위치에 배치시킨다
- k 또한 서버처럼 함수를 거쳐 특정 위치에 배치시킨다
- k가 저장된 s찾기: k 위치로부터 시계방향으로 링을 탐색하면 첫 번째로 만나는 s
- s가 추가되거나 제거되면 해당 영역에 존재하던 k만 재배치하면 된다.

![image](https://user-images.githubusercontent.com/53105735/235166366-f7666cd9-ee6b-4594-bd36-b6146d910404.png)

### 가상 노드

안정 해시는 2가지 문제가 있다.
- 파티션의 크기를 균등하게 유지하는 것이 불가하다
  - s와 다른 s의 공간 크기 격차가 클 수 있다
- 키의 균등 분포 달성이 어렵다
  - 특정 s에만 k가 몰려있을 수 있다

이를 해결하기 위해 등장한 것이 가상 노드이다.  

- = virtual node
- 실제 노드 또는 서버를 가리키는 노드
- 하나의 서버는 여러개의 가상 노드를 가질 수 있다
- 가상 노드의 개수를 늘릴수록 키의 분포는 점점 더 균등해진다 (가상 노드 데이터를 저장할 공간이 더 필요하므로 적당한 조정 필요)


## ch06. 키-값 저장소 설계

## 키-값 저장소

- = key-value store = 키-값 데이터베이스
- 비 관계형 데이터베이스의 일종으로 모든 '값'은 '키'라는 고유 식별자를 갖고 저장된다
- ex: Amazon Dynamo, memcaches, Redis, ...

### 단일 서버 키-값 저장소

- 키-값 쌍 전부를 메모리에 해시 테이블로 저장하면 된다.
- 모든 데이터를 메모리 안에 두는 것은 한계가 존재한다.
  - 개선방법1: 데이터 압축
  - 개선방법2: 자주 쓰이는 데이터만 메모리에 두고, 나머지는 디스크에 저장

### 분산 키-값 저장소 

- = 분산 해시 테이블
- CAP의 요구사항 모두를 충족할 수는 없음 (일반적으로 2가지 만족)

> **CAP**  
> Consistency; 일관성: 모든 클라이언트는 노드 종류에 상관없이 언제나 같은 데이터를 볼 수 있다.  
> Availability; 가용성: 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받을 수 있다.  
> Partition Tolerance; 파티션 감내: 네트워크에 파티션이 생겨도 시스템은 계속 동작해야 한다.  
> (Partition; 파티션: 두 노트 사이에 통신 장애가 발생함을 의미)

### 시스템 컴포넌트
> 키-값 저장소 구현에 사용될 핵심 컴포넌트 및 기술

- 데이터 파티션
  - 데이터를 작은 파티션으로 분할해 여러 대 서버에 저장한다
- 데이터 다중화; replication
  - 높은 가용성과 안정성 확보를 위함
  - 데이터를 n개 서버에 비동기적으로 다중화해야 함
- 일관성; consistency
  - 여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 함
  - 정족수 합의 프로토콜 (N=사본 개수, W=쓰기 연산에 대한 정족수, R=읽기 연산에 대한 정족수)
  - ex: R=1, W=N: 빠른 읽기 연산에 최적화된 시스템 / W+R>N: 강한 일관성이 보장된 시스템
- 일관성 불일치 해소
  - 데이터 다중화 시 가용성은 높아지지만 사본 간 일관성은 깨질 가능성도 높아짐
  - 버저닝, 벡터 시계를 통해 해소 가능
- 장애 처리
  - 장애를 감지하고 해소하는 방법
- 시스템 아키텍처 다이어그램
- 쓰기 경로
- 읽기 경로

### 요약

|목표/문제|기술|
|--|--|
|대규모 데이터 저장|안정 해시를 사용해 서버들에 부하 분산|
|읽기 연산에 대한 높은 가용성 보장|데이터를 여러 데이터센터에 다중화|
|쓰기 연산에 대한 높은 가용성 보장|버저닝 및 벡터 시계를 통한 충돌 해소|
|데이터 파티션|안정 해시|
|점진적 규모 확장성|안정 해시|
|다양성|안정 해시|
|조절 가능한 데이터 일관성|정족수 합의; quorum consensus|
|일시적 장애 처리|느슨한 정족수 프로토콜(sloppy quorum)과 단서 후 임시 위탁(hinted handoff)|
|영구적 장애 처리|머클 트리; merkle tree|
|데이터 센터 장애 대응|여러 데이터 센터에 걸쳐 데이터 다중화|


## ch07. 분산 시스템을 위한 유일 ID 생성기 설계

### 유일성이 보장되는 ID 생성

- 다중 마스터 복제
  - DB의 auto_increment 기능 활용
  - k(서버 수)만큼 증가
  - 데이터 센터 확장이 어려워짐
  - ID 값이 시간의 흐름 순으로 생성되지는 않음
  - 서버 추가/삭제 시 잘 동작하도록 만드는 것이 어려움
- UUID
  - 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128bit 수
  - 서버 규모 확장이 쉬움
  - ID가 128bit 길다
  - ID 시간순으로 정렬 불가
  - 숫자가 아닌 값이 포함됨
- 티켓 서버
  - ID 생성을 위한 서버 별도로 구축
  - 구현하기 쉽고 유일성이 보장되는 ID 사용 가능
  - 티켓 서버가 SPOF(Single Point of Failure)가 됨
- 트위터 스노플레이크 접근법
  - ID구조를 여러 절로 분할
  - sign: 나중을 위해 유보. 음수양수 구별하는데 사용 가능
  - timestamp: 현재 시간
  - datacenter id
  - server id
  - 일련번호: 각 서버에서 생성하는 id (1씩 카운트하다 1밀리초가 경과할 때마다 0으로 초기화)

## ch08. URL 단축키 설계

### URL 리디렉션

1. client -> server 단축 url로 API 요청
2. server -> client 상태코드 301 + Location: 원본 url
3. client -> server 원본 url로 API 요청
4. server -> client 응답

### 단축 URL 설계

- 데이터 모델: 간편한 구축을 위해 RDB에 id, shortUrl, longUrl 저장한다고 가정
- 해시 함수: 원래 url을 단축 url로 변환하는데 사용

- 해시 충돌 해소
  - 해시 함수를 사용하면 충돌이 나는 상황이 발생할 수 있음
  - 매번 DB에서 중복되는지 검사하기에는 오버헤드가 큼
  - 블룸 필터를 통해 성능 높일 수 있음

### 추가 공부

- 처리율 제한 장치: 엄청난 양의 url 단축 요청이 들어올 경우에 대비해 처리율 제한 장치를 설계
- 웹 서버의 규모 확장: 본 설계는 무상태 계층이므로 웹 서버의 규모를 확장하기 쉬움
- 데이터베이스 규모 확장: DB 다중화, 샤딩을 통해 규모 확장 달성 가능
- 데이터 분석 솔루션: url 단축기에 데이터 분석 솔루션을 통합해 얼마나 많은 사용자가 클릭했는지 확인 가능
- 가용성, 데이터 일관성, 안전성
