# Chapter 13. 모델링: 클래스 설계의 토대

### 시스템, 모델, 모델링
- 시스템
  - : 수많은 구성 요소로 이루어진 집합체로서, 각 부분이 유기적으로 연결되어, 전체적으로 하나의 목적을 갖고 움직이는 것
  - ex: 사람은 두 다리로 번갈아 움직이며 이동하는 이족보행 시스템을 따름
  - 목적 달성을 위한 수단
- 모델
  - 시스템 구조를 설명하기 위해 단순한 상자로 도식화한 것
  - 시스템의 구성 요소 -> 특정 목적 달성을 위해 최소한의 필요 요소를 갖춘 것
- 모델링
  - 모델의 의도를 정의하고, 구조를 설계하는 것

### 모델링 tip
- '목적'별로 모델링하기
- 모델은 특정 대상이 아니라 목적 달성의 수단이다
  - 사용자, 상품 등의 어떤 사물이나 대상체 등을 모델로 잡으면 많은 정보를 담느라 데이터가 거대해진다
  - 특정 목적 달성과 관련된 부분만 추려 표현하자
  - ex: 사용자를 User로 표현하기보단, 사용자에 대한 특징을 Profile로, 로그인할 때 필요한 정보를 PersonalAccount 등으로 표현
- 단일 책임, 단일 목적
- 모델을 설계했다면, 해당 모델이 달성하려는 목적을 다시 확인해보자
  - 목적 이외의 요소가 들어있다면 수정 필요
- 모델 != 클래스
  - 모델 : 클래스 = N : 1에 가까움
  - 모델을 클래스와 코드로 정교화하며 어색한 것은 없는지, 필수적인 요소는 다 넣었는지 등을 피드백

### 기능성과 목적

- 기능성: 고객의 니즈를 만족하는 정도
- 숨어있는 목적을 잘 파악하자
  - 상품 구매를 하면 '상품 구입'과 '구입 품목'에 대해서만 생각해도 될 것 같지만, 법적인 요소도 고려해야함
  - 기능을 제대로 동작시키려면, 숨어 있는 목적까지 잘 파악해야함

# Chapter 14. 리팩터링: 기존의 코드를 성장시키는 기술

- 리팩터링: 실질적인 동작은 유지하면서, 구조만 정리하는 작업
- 중첩문을 제거한다, 의미 있는 단위로 로직을 정리한다(메서드 추출이라거나) 등
- 안전하게 리팩터링 하는 방법: 단위 테스트를 꼼꼼하게 작성한다
- 알 수 없는 레거시 리팩터링하기
  - 기존 코드를 이용해 input, output 목록을 정리한다
  - 위 과정을 통해 완벽한 사양을 밝히기는 어렵지만 전보다는 명확하게 만들 수 있음
  - 스크래치 리팩터링: 로직의 의미와 구조를 분석하기 위한 리팩터링
- 리팩터링 주의사항
  - 리팩터링과 기능 추가 동시에 하지 않기
  - 작은 단계로 실시하기

# Chapter 15. 설계의 의의와 설계를 대하는 방법

소프트웨어 품질과 관련된 특성
- 기능 적합성: 니즈를 만족하는가
- 성능 효율성
- 호환성
- 사용성: 사용자가 시스템을 만족하며 사용하는가
- 신뢰성
- 보안: 허용되지 않은 사용자로부터 보호
- 유지 보수성
- 이식성: 다른 실행 환경에 이식할 수 있는지

생산성 저하 요인
- 버그가 발생하기 쉬운 구조
- 가독성이 낮은 구조

코드 변경의 목적
- 소프트웨어의 가치를 높이기 위해
- 소프트웨어의 성장 가능성을 높이기 위해

메모
- 엔지니어에게 자산이란 기술력이다
- 레거시 코드는 발전을 막는다
- 이상적인 형태를 알아야 문제도 인식할 수 있다
  - 문제는 이상과 현실 차이에서 발생한다. 이상이 무엇인지 안다면 현실과 비교해가며 차근차근 해결할 수 있다
- 클래스를 작게 분할하는 것에 거부감을 갖는 사람들에게. 라이브러리 내부 구현이 어떻게 구현되어있는지 하나하나 신경쓰는 사람이 있나요? 코드에 대한 신뢰성이 낮기 때문에 분할을 불안해하는 것입니다.
  - 맥락과는 다른 이야기지만.. 최근에 이것 때문에 피봐서... 신경써야할 필요성을 느꼈다;;

# Chapter 16. 설계를 방해하는 개발 프로세스와의 싸움

> 개발 프로세스 자체가 레거시 코드의 발생 원인이 되기도 한다

### 커뮤니케이션이 부족하다
- 커뮤니케이션의 부족: 정보를 바라보는 관점이 다르다, 사이가 좋지 않다 등
- 콘웨이 법칙: 시스템 구조는 그것을 설계하는 조직의 구조를 닮아 간다
  - 3개의 조직으로 이루어진 곳이면 3개로 구성된 시스템이 만들어지기 쉽다
- 역콘웨이 법칙: 소프트웨어 구조를 먼저 설계하고, 이후 소프트웨어의 구조에 맞게 조직을 편성한다
- 심리적 안정성: 어떤 발언을 했을 때, 부끄럽거나 거절당하지 않을 것이라는 확신을 느낄 수 있는 심리 상태

### 설계가 제대로 이루어지지 못하다
- 빨리 끝내고싶다는 심리
- 클래스 설계와 구현 피드백 사이클 돌리기
  - 최소한 메모라도 클래스 다이어그램을 그리며 사양 변경하기
  - 이게 현실적으로 가능할까? 실제로는 비즈니스가 굉장히 복잡하게 되어있는데 클래스 다이어그램을 그리는데만 엄청 오래걸리지 않을까.. 대대적인 리팩터링을 각오하지 않고서는 가능할지 잘 모르겠다.
- 한번에 완벽하게 만들지 말고, 사이클을 돌리며 완성하기
- 너무 빠른 최적화; premeature optimization: 병목이 어디인지 모른 채 성능이 빠른 코드를 작성하려고만 하는 것
- 무작정 다수결로 설계 규칙을 만들지 말자
  - 설계 역량이 뛰어난 팀원이 중심이 되어 규칙을 만드는 것이 좋다
  - 모두의 의견을 설득하려다보면 수준이 낮은 쪽에 하향평준화될 수 있음 -> 말이 넘하네 ㅋㅋㅋ ㅠㅠㅠㅠ
  - 설계 규칙의 의도가 한번에 전달되기 힘듦 -> 리뷰와 스터디 등을 통해 의도를 계속 전달
  - 팀 구성원의 설계 역량이 어느 정도 성숙해지면 다시 설계 규칙에 대해 논의하기

### 구현
- 나쁜 구조가 눈에 띄면 조금씩이라도 좋으니 개선하는 습관을 기르자
  - 기존의 나쁜 코드를 보면 내 코드도 별로지만 저거보단 낫지..라는 생각을 하게 될 수 있음  
- 기존의 코드를 믿지 말고 냉정하게 파악하기
  - 히스토리를 완전히 파악하지 못한 사람에게는 기존 코드가 정말..... 일종의 규칙이나 기준선처럼 느껴지는데 어쩌면 좋을까
- 코딩 규칙 사용하기 - 코드 작성 방식 통일

### 리뷰
- 코드 리뷰 구조화
- 설계 시점에 리뷰 - 로직이 기능 요건을 만족하는 것도 중요하지만, 설계적 타당성을 중심으로 리뷰하는 것이 더 중요
- 공격적인 말 X. 존중과 예의
- 스케줄상 나중에 개편할 것으로 남긴 것은 이슈 등의 기능을 통해 꼭 나중의 과제로 남겨두기 - 잊혀지고 방치되기 쉽상
