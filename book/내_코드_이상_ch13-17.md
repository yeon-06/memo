# Chapter 13. 모델링: 클래스 설계의 토대

### 시스템, 모델, 모델링
- 시스템
  - : 수많은 구성 요소로 이루어진 집합체로서, 각 부분이 유기적으로 연결되어, 전체적으로 하나의 목적을 갖고 움직이는 것
  - ex: 사람은 두 다리로 번갈아 움직이며 이동하는 이족보행 시스템을 따름
  - 목적 달성을 위한 수단
- 모델
  - 시스템 구조를 설명하기 위해 단순한 상자로 도식화한 것
  - 시스템의 구성 요소 -> 특정 목적 달성을 위해 최소한의 필요 요소를 갖춘 것
- 모델링
  - 모델의 의도를 정의하고, 구조를 설계하는 것

### 모델링 tip
- '목적'별로 모델링하기
- 모델은 특정 대상이 아니라 목적 달성의 수단이다
  - 사용자, 상품 등의 어떤 사물이나 대상체 등을 모델로 잡으면 많은 정보를 담느라 데이터가 거대해진다
  - 특정 목적 달성과 관련된 부분만 추려 표현하자
  - ex: 사용자를 User로 표현하기보단, 사용자에 대한 특징을 Profile로, 로그인할 때 필요한 정보를 PersonalAccount 등으로 표현
- 단일 책임, 단일 목적
- 모델을 설계했다면, 해당 모델이 달성하려는 목적을 다시 확인해보자
  - 목적 이외의 요소가 들어있다면 수정 필요
- 모델 != 클래스
  - 모델 : 클래스 = N : 1에 가까움
  - 모델을 클래스와 코드로 정교화하며 어색한 것은 없는지, 필수적인 요소는 다 넣었는지 등을 피드백

### 기능성과 목적

- 기능성: 고객의 니즈를 만족하는 정도
- 숨어있는 목적을 잘 파악하자
  - 상품 구매를 하면 '상품 구입'과 '구입 품목'에 대해서만 생각해도 될 것 같지만, 법적인 요소도 고려해야함
  - 기능을 제대로 동작시키려면, 숨어 있는 목적까지 잘 파악해야함

# Chapter 14. 리팩터링: 기존의 코드를 성장시키는 기술

- 리팩터링: 실질적인 동작은 유지하면서, 구조만 정리하는 작업
- 중첩문을 제거한다, 의미 있는 단위로 로직을 정리한다(메서드 추출이라거나) 등
- 안전하게 리팩터링 하는 방법: 단위 테스트를 꼼꼼하게 작성한다
- 알 수 없는 레거시 리팩터링하기
  - 기존 코드를 이용해 input, output 목록을 정리한다
  - 위 과정을 통해 완벽한 사양을 밝히기는 어렵지만 전보다는 명확하게 만들 수 있음
  - 스크래치 리팩터링: 로직의 의미와 구조를 분석하기 위한 리팩터링
- 리팩터링 주의사항
  - 리팩터링과 기능 추가 동시에 하지 않기
  - 작은 단계로 실시하기

# Chapter 15. 설계의 의의와 설계를 대하는 방법

소프트웨어 품질과 관련된 특성
- 기능 적합성: 니즈를 만족하는가
- 성능 효율성
- 호환성
- 사용성: 사용자가 시스템을 만족하며 사용하는가
- 신뢰성
- 보안: 허용되지 않은 사용자로부터 보호
- 유지 보수성
- 이식성: 다른 실행 환경에 이식할 수 있는지

생산성 저하 요인
- 버그가 발생하기 쉬운 구조
- 가독성이 낮은 구조

코드 변경의 목적
- 소프트웨어의 가치를 높이기 위해
- 소프트웨어의 성장 가능성을 높이기 위해

메모
- 엔지니어에게 자산이란 기술력이다
- 레거시 코드는 발전을 막는다
- 이상적인 형태를 알아야 문제도 인식할 수 있다
  - 문제는 이상과 현실 차이에서 발생한다. 이상이 무엇인지 안다면 현실과 비교해가며 차근차근 해결할 수 있다
- 클래스를 작게 분할하는 것에 거부감을 갖는 사람들에게. 라이브러리 내부 구현이 어떻게 구현되어있는지 하나하나 신경쓰는 사람이 있나요? 코드에 대한 신뢰성이 낮기 때문에 분할을 불안해하는 것입니다.
  - 맥락과는 다른 이야기지만.. 최근에 이것 때문에 피봐서... 신경써야할 필요성을 느꼈다;;
