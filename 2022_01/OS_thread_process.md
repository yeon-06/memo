# 프로세스와 스레드

### 차이점
#### 프로세스
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
- OS로부터 시스템 자원을 할당받는 작업의 단위

#### 스레드
- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세스의 코드에 정의된 절차에 따라 실행되는 특정한 수행 경로

> 프로그램  
> : 어떤 작업을 위해 실행할 수 있는 파일  
> 프로그램이 실행되기 위해서는 OS가 독립적인 메모리 공간을 할당해주어야 한다.  
> 프로그램은 일반적으로 메모리에 올라가지 않은, Windows의 `*.exe`파일 같은 실행 전의 정적인 파일을 의미.

### 메모리 영역
![프로세스와 스레드 메모리](../images/process_thread.png)

- 스레드는 프로세스 내에서 Stack만 할당받음
- 같은 프로세스에 존재하는 여러 스레드들은 `Code`, `Data`, `Heap` 영역 공유
- 프로세스는 다른 프로세스 메모리에 직접 접근 불가
- 프로세스 실행 중 오류 발생 시 다른 프로세스에 영향 X  
  스레드 실행 중 오류 발생 시 메모리 영역을 공유하므로 같은 프로세스 내 다른 스레드가 강제 종료

> 각 데이터 영역의 저장 정보  
> `코드`: 현재 프로세스에서 실행 중인 프로그램의 바이너리 코드  
> `데이터`: 전역 변수, 상수 등  
> `힙`: 런타임에 할당할 메모리 영역  
> `스택`: 지역 함수, 변수처럼 현재 실행 중인 컨텍스트와 관련된 정보

> 프로세스의 정보에는 접근이 불가능하다?  
> 👉 사실 아예 불가능하지는 않지만 CPU 레지스터 교체나 RAM과 CPU 사이의 캐시 메모리까지 초기화되기 때문에 **자원적 부담**이 큼  
> (1) IPC; Inter-Process Communication 사용  
> (2) LPC; Local inter-Process Communication 사용  
> (3) 별도로 공유 메모리를 생성해 정보 주고받도록 설정  

***

### 멀티 프로세스와 멀티 스레드
#### 멀티 프로세스
- 하나의 응용 프로그램을 여러 프로세스로 구성해 각 프로세스가 하나의 작업을 처리하도록 하는 것
- 여러 자식 프로세스 중 하나가 **문제 발생 시** 해당 프로세스만 죽음. **영향 X**
- **Context-Switching**에서의 **오버헤드**
  - 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모
  - 프로세스 사이에 공유된 메모리가 없어 `Context Switching` 발생 시 캐시의 모든 데이터를 리셋하고 정보를 불러와야 함
- 프로세스 사이의 어렵고 복잡한 통신 기법 (IPC)

#### 멀티 스레드
- Context-Switching 시 공유하는 메모리 만큼 **메모리 자원을 아낄 수 있음**
- 스레드는 `Stack 영역`을 제외한 모든 메모리를 공유해 통신의 부담이 적음 -> **응답 시간 ↓**
- 한 스레드가 프로세스 내 자원 망치면 모든 프로세스가 종료되어야 함
- 자원 공유로 인한 **동기화 문제**
- 각 스레드는 자신만의 실행 상태를 가질 수 있어 서로 다른 CPU에서도 동작 가능  
  -> 여러 CPU를 단일 회로로 통합한 멀티 코어 프로세서를 이용하면 물리적인 병렬 처리 가능

### Context-Switching  
- 현재 진행중인 프로세스, 스레드 등의 상태를 저장하고 다음 진행할 task의 상태 값을 읽어 적용하는 과정
- 인터럽트 기반으로 동작.  
  인터럽트 발생 시 CPU가 진행 중인 작업 중단  
  -> 해야할 일이 정의된 인터럽트 서비스 루틴 수행

1. 현재 실행 중인 Task의 PCB 정보 저장
2. 다음 실행할 Task의 PCB 정보 읽어 Register에 적재

### 멀티 스레드의 동기화 문제
- 둘 이상의 스레드가 동일한 자원에 접근해 작업한 경우 문제 발생
> [동기화와 데드락](./OS_synchronize_deadlock.md) 참고

### PCB (=Process Control Block)
- 멀티 태스킹에서 커널이 각 프로세스의 정보를 저장하고 관리하기 위해 사용  
  (스레드의 정보를 저장하는건 Thread Control Block으로 PCB에 저장됨)
- PCB의 레지스터에 프로그램 카운터 저장  
  (프로그램 카운터: Context Switching이 일어날 때 현재까지 실행된 코드와 다음으로 실행할 코드 주소)
- 프로세스 상태를 5개로 관리
  - `new`: 프로세스를 위한 PCB가 생성되었지만 메모리에는 올라가있지 않은 상태
  - `ready`: 프로세스가 CPU를 점유하고 사용이 가능한(dispatch) 상태
  - `running`: 프로세스가 현재 CPU를 점유해 작업을 처리 중인 상태
  - `waiting`: `running` 상태인 프로세스가 입출력을 요청한 후 입출력 완료때까지 기다리는 상태
  - `terminated`: 프로세스가 작업을 완료해 메모리 자원을 반납하고 PCB가 삭제된 상태

***

### 인터럽트
- 인터럽트 당한 시점의 레지스터와 프로그램 카운터를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘김
- 하드웨어 인터럽트: 하드웨어가 발생시킨 인터럽트
- 소프트웨어 인터럽트
  - Exception: 프로그램의 오류 발생
  - System Call: 프로그램이 커널 함수 호출

#### 명령어 종류
- `일반 명령`: 메모든 프로그램이 수행할 수 있는 명령
- `특권 명령`: 보안이 필요한 명령 (ex: 입출력 장치, 타이머 장치 접근 명령 등)

#### 커널 모드 vs 사용자 모드
- `커널 모드`: OS가 CPU의 제어권 갖고 명령 수행. 특권 명령 수행 가능
- `사용자 모드`: 일반 사용자 프로그램이 CPU 제어권 갖고 명령 수행. 일반 명령만 수행 가능


### 사용자 수준 스레드와 커널 수준 스레드
#### 커널 레벨 스레드
- 커널 모드로 작동되는 스레드
- 커널 레벨에서 생성되는 커널이 직접 관리하는 스레드
- 안정성과 다양한 기능 제공
- 유저 모드 -> 커널 모드로의 잦은 전환으로 인한 성능 저하

#### 사용자 레벨 스레드
- 사용자 모드로 작동되는 스레드
- 커널에 의존적이지 않은 형태로 스레드의 기능을 제공하는 라이브러리 등을 활용해 제공되는 스레드
- 유저, 커널 모드의 전환 X
- 커널에 의해 스레드가 블로킹/인터럽트 되면 프로세스 전체가 블로킹

#### 
- Pure user-level
  - 커널 스레드 : 사용자 스레드 = 1 : n
  - 커널은 사용자 스레드가 몇 개가 있든 전혀 모름
  - 사용자 스레드에서 I/O가 하나라도 발생하면 해당 프로세스는 I/O가 풀릴 때 까지 계속 block
- Pure kernel-level
  - 커널 스레드 : 사용자 스레드 = 1 : 1
  - 병렬성 ↑
  - 효율성 ↓
- Combined
  - 커널 스레드와 사용자 스레드 혼합해 사용

***
참고
1. [velog - @raejoonee](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)
2. [github - nesoy](https://nesoy.github.io/articles/2018-11/Context-Switching)
3. [레스토랑에 비유해서 알아보는 운영체제](https://wormwlrm.github.io/2021/10/04/OS-Restaurant.html)
4. [KOCW 무료 강의 - 반효경 교수님의 운영체제](http://www.kocw.or.kr/home/cview.do?mty=p&kemId=1226304&ar=relateCourse)
5. [github - splin / 뮤텍스, 세마포어, 모니터](https://dev-splin.github.io/cs(computer%20science)/operating%20system/OS-Mutex,Semaphore,Monitor/)
