# Kafka

- 분산 이벤트 스트리밍 플랫폼
- 기본 구조 (아래 이미지 참고)

![image](https://user-images.githubusercontent.com/53105735/216339762-c658c2d2-4cb4-40d0-a119-b7d4243e12b0.png)

<br/>

### 카프카를 왜 사용해야할까

> 잘란도라는 기업과 살펴보는 카프카

1. 데이터에 대한 온갖 요구사항이 불거지자 근본적인 해결 대책을 강구
2. 데이터의 변화가 스트림으로 컨슈머 측에 전달되는 이벤트 드리븐 시스템으로 전환
3. REST API를 통해 데이터 오차를 줄이려는 노력
    - 여러 네트워크를 이용하는 환경에서 모든 데이터 변경에 대한 올바른 전달 보장 문제
    - 동일한 데이터를 동시에 수정하며 정확한 순서를 보장해야 하는 문제
    - 수정된 이벤트들을 정확한 순서대로 아웃바운드 전송하는 문제
    - 다양한 클라이언트들의 요구사항을 효율적으로 지원하기 어려운 문제
    - 빠른 전송을 위한 클라이언트나 대량 배치 전송을 위한 클라이언트를 지원하기 어려운 문제
4. 동기 방식의 한계를 느껴 비동기 방식의 대표 스트리밍 플랫폼인 카프카 선택

<br/>

### 카프카의 장점

- 빠른 데이터 수집이 가능한 높은 처리량
- 이벤트 처리 순서 보장
- 적어도 한 번 전송 방식
  - 이벤트가 중복 발생할 수는 있으나 누락 없는 재전송이 가능
  - 메시지 손실에 대한 걱정이 사라짐
- 자연스러운 백프레셔 핸들링
  - 카프카 클라이언트는 풀 방식으로 동작해 자기 자신의 속도로 데이터를 처리할 수 있음
  - 이와 반대로 푸시 방식은 브로커가 보내주는 속도에 의존적임
- 강력한 파티셔닝
  - 논리적으로 토픽을 여러개 나눌 수 있음

### 왜 카프카 성능이 좋을까?

- 파티션 파일은 OS 페이지 캐시를 사용
  - 파티션에 대한 파일 I/O를 메모리에서 처리
  - 서버에서 페이지 캐시를 카프카만 사용해야 성능에 유리
- Zero Copy
  - 디스크 버퍼에서 네트워크 버퍼로 직접 데이터 복사
- 컨슈머 추적을 위해 브로커가 하는 일이 비교적 단순
  - 메시지 필터, 재전송 같은 일을 하지 않음 (프로듀서, 컨슈머가 함)
  - 컨슈머와 파티션 간 매핑 관리
- 배치 가능
  - 프로듀서는 일정 크기만큼 메시지를 모아 전송 가능
  - 컨슈머는 최소 크기만큼 메시지를 모아 조회 가능
  - 낱개 처리보다 처리량 증가
- 처리량 확장이 쉬움
  - 장비 용량이 한계에 다다르면 브로커나 파티션을 추가하면 됨
  - 컨슈머가 느리면 컨슈머나 파티션을 추가하면 됨

<br/>

### 그 외의 다른 장점들

- 리플리카
  - : 파티션의 복제본
  - 복제수만큼 파티션의 복제본이 각 브로커에 생김
- 리더-팔로워 구성
  - 프로듀서와 컨슈머는 리더를 통해서만 메시지 처리
  - 팔로워는 리더로부터 복제
- 장애 대응
  - 리더가 속한 브로커 장애 시 다른 팔로워가 리더가 됨

<br/>

***

#### 참고 자료
- https://www.youtube.com/watch?v=0Ssx7jJJADI&ab_channel=%EC%B5%9C%EB%B2%94%EA%B7%A0
- 실전 카프카 개발부터 운영까지
