# 컨슈머; Consumer

- 카프카에 저장된 메시지를 꺼내오는 역할


## 오프셋 관리

- `오프셋`: 메시지를 나타내는 위치
- `__consumer_offsets`: 컨슈머 그룹이 읽은 오프셋을 저장하는 토픽. (읽은 위치가 아닌 다음으로 읽어야 할 위치를 저장)

### 그룹 코디네이터

- 컨슈머 그룹
  - 여러개의 컨슈머로 구성
  - 컨슈머는 그룹에서 들어오고 나가는 것이 자유로움
  - 그룹 내의 변화를 인지하며 각 컨슈머들에게 작업을 균등하게 분배해야 함 (= 컨슈머 리밸런싱)
    - 경우에 따라 높은 비용이 지출되므로 자주 발생하지 않도록 해야함
    - 컨슈머를 재시작하면 전체 리밸런싱이 일어남
- 그룹 코디네이터
  - : 안정적인 컨슈머 그룹 관리를 하기 위한 코디네이터
  - 컨슈머 그룹이 구독한 토픽의 타피션들과 그룹의 멤버들 트래킹 목적
  - 컨슈머 그룹이 브로커에 최초 연결을 요청하면 브로커 중 하나에 생성됨

<img width="630" alt="image" src="https://github.com/yeon-06/memo/assets/53105735/c67a997d-0cfe-440b-9291-c53556f7cac0">

1. 컨슈머 -> 브로커: 컨슈머 클라이언트와 초기 커넥션을 연결하기 위한 요청 전송
2. 브로커: 그룹 코디네이터 생성 및 컨슈머에게 응답
3. 그룹 코디네이터: 컨슈머의 요청 대기
4. 컨슈머 -> 그룹 코디네이터: 컨슈머 등록 요청 (가장 먼저 요청을 보내는 컨슈머가 컨슈머 그룹의 리더가 됨)
5. 그룹 코디네이터 -> 컨슈머: 요청에 대한 응답
6. 리더 컨슈머: 정해진 컨슈머 파티션 할당 전략에 따라 그룹 내 컨슈머들에게 파티션을 할당한 뒤 그룹 코디네이터에 전달
7. 그룹 코디네이터: 해당 정보 캐시, 각 그룹 내 컨슈머들에게 성공 알림
8. 컨슈머들: 각자 지정된 토픽 파티션으로부터 메시지 가져옴

- 컨슈머들의 변경 감지
  - 컨슈머가 직접 등록/삭제 요청 전송
  - 그룹 코디네이터-컨슈머 간 하트비트 전송

### 스태틱 멤버십

#### 도입 배경
- 컨슈머 재시작을 하면 전체 리밸런싱이 일어남
  - 컨슈머 그룹 내에서는 컨슈머를 구분하기 위한 ID들을 임시로 사용
  - 컨슈머 설정 변경이나 s/w 업데이트 등으로 컨슈머 재시작 시 기존의 동일 컨슈머임에도 새로운 컨슈머로 인식 -> 새로운 ID 부여
  - 컨슈머 그룹의 리밸런싱 발생
- 이런 불필요한 리밸런싱 방어를 위해 스태틱 멤버십 도입 (2.3 버전 ~)

#### 스태틱 멤버십
- 컨슈머마다 인식할 수 있는 ID를 적용해 다시 합류해도 기존 구성원임을 인식할 수 있게 해줌
- 스태틱 멤버십을 적용해도 session.timeout.ms 지정된 시간을 넘어가면 리밸런싱이 일어날 수 있음

## 컨슈머 파티션 할당 전략

- 컨슈머에서는 대상 토픽의 어느 파티션으로부터 레코드를 읽어올까?
- 컨슈머 그룹의 리더 컨슈머가 정해진 파티션 전략에 따라 각 컨슈머와 대상 토픽의 파티션을 매칭
  - 레인지 파티션 할당 전략: default. 토픽별로 할당 전략 사용
  - 라운드 로빈 파티션 할당 전략: 사용 가능한 파티션과 컨슈머들을 RR로 할당
  - 스티키 파티션 할당 전략: 컨슈머가 컨슘하는 파티션 계속 유지
  - 협력적 스티키 파티션 할당 전략: 스티키와 유사. 전체 일시 정지 X. 연속적인 재조정 방식 O.

### 레인지 파티션 할당 전략

1. 구독하는 토픽에 대한 파티션을 순서대로 나열한 후 컨슈머를 순서대로 정렬
2. 컨슈머당 몇 개의 파티션 할당해야 하는지 확인 (전체 파티션 수/컨슈머 수)
3. 파티션 수가 균등하게 할당되지 않는 경우, 앞쪽의 컨슈머들이 추가 파티션 할당

### 라운드 로빈 파티션 할당 전략

1. 컨슘해야 하는 모든 파티션과 모든 컨슈머 나열
2. RR 방식으로 하나씩 파티션과 컨슈머 할당

### 스티키 파티션 할당 전략

- 컨슈머 그룹의 리밸런싱으로 인해 파티션 재할당되는 경우, 레인지 파티션과 RR 파티션 할당 전략은 기존에 매핑되었던 파티션과 동일한 컨슈머가 다시 매핑될 것이라 보장할 수 없음
- 기존에 매핑됐던 파티션-컨슈머를 최대한 유지하려고 하는 전략

#### 목적
- 가능한 균형 잡힌 파티션 할당 ⭐️
- 재할당 발생 시 되도록이면 기존에 할당된 파티션 정보 보장

1. 최초 배치 시에는 RR와 흡사
2. 컨슈머2 제외 -> 컨슈머1, 3에 할당된 파티션들은 유지
3. 컨슈머2에 할당된 파티션들만 컨슈머 1, 3에 할당

### 협력적 스티키 파티션 할당 전략

- 스티키 파티션 할당보다 리밸런싱 동작이 고도화
- 기존의 컨슈머 리밸런싱 동작에서는 EAGER라는 리밸런스 프로토콜 사용
  - EAGER는 컨슈머 리밸런싱 동작 시 컨슈머에 할당된 모든 파티션을 항상 취소 (전체 컨슈머가 일시적으로 멈춘 상태에서 리밸런싱이 일어남)
    - 이유1: 컨슈머들의 파티션 소유권 변경
    - 이유2: 그룹 내에서 여러 파티션들에 대해 소유권 변경이 동시에 이루어져야 해서 로직을 단순하게 만들기 위해
- 2.4 버전부터 컨슈머 클라이언트에 COOPERATIVE 프로토콜 적용
  - 리밸런싱이 동작하기 전의 컨슈머 상태를 유지할 수 있게 함
  - 동작 중인 컨슈머들에게 영향을 주지 않는 상태에서 몇 차례에 걸쳐 리밸런싱 동작

1. 컨슈머 그룹에 새로운 컨슈머 추가 -> 리밸런싱 트리거
2. 컨슈머들 -> 그룹 코디네이터: 자신들이 컨슘하는 토픽의 파티션 정보(소유권) 전송
3. 그룹 코디네이터: 해당 정보를 조합해 컨슈머 그룹의 리더에게 전송
4. 컨슈머 그룹의 리더 -> 컨슈머 그룹 멤버들: 제외할 파티션 정보를 담은 새로운 파티션 할당 정보를 만들어 전송
5. 컨슈머 그룹 멤버들: 현재의 파티션 할당 전략과 차이를 비교해 필요 없는 파티션들을 골라 제외
6. 컨슈머들: 제외된 파티션 할당을 위해 다시 합류 요청 -> 리밸런싱 트리거
7. 컨슈머 그룹 리더: 제외된 파티션을 적절한 컨슈머에게 할당

## 정확히 한 번만 동작

- 브로커 측에서 전체 트랜잭션을 관리하며 프로듀서의 동작ㄹ을 보조하는 별도의 트랜잭션 코디네이터가 존재
- 트랜잭션 코디네이터가 프로듀서의 정확히 1번 전송 성공 시 해당 레코드의 트랜잭션 성공을 표시하는 특수한 메시지 추가
- **트랜잭션 컨슈머라고 해서 정확히 한 번만 가져오지는 않는다.**
  - 프로듀서: 트랜잭션 코디네이터와 통신하며 해당 트랜잭션이 정확하게 처리되는 것을 보장
  - 컨슈머: 트랜잭션 프로듀서가 보낸 메시지만 가져올 수 있는지에 대해서만 옵션으로 선택 가능 (=트랜잭션 코디네이터와 통신하는 부분 X)
    - 따라서 정확히 한 번 가져오는지 보장이 불가함
    - 컨슈머에 의해 컨슘된 메시지가 다른 싱크 저장소로 중복 저장될 수 있음
    - 정확히 한 번 메시지를 가져왔더라도 다른 애플리케이션에 저장하는 과정에서 중복처리될 수 있음
  - 컨슈머의 동작까지 정확히 한 번 처리하려면 '컨슘 ~ 메시지 처리 ~ 프로듀싱' 동작이 하나의 트랜잭션으로 처리되어야 함

