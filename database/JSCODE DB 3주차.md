### 랜덤 I/O와 순차 I/O에 대해서 설명해주세요.

- 디스크 I/O는 다른 I/O에 비해 성능의 발전이 더딘 편이다.
- 따라서 DB의 성능 튜닝은 디스크 I/O를 줄이느냐가 관건일 때가 많다.
- 랜덤 I/O: 데이터가 물리적으로 불연속적으로 있기 디스크 헤드를 여러번 이동시킴
- 순차 I/O: 데이터가 연속적으로 존재해 디스크 헤드를 1번 이동시켜서 쭉 읽음

(+) 쿼리 튜닝은 랜덤 I/O를 순차 I/O로 변경하는 작업인가요?
- 그런 상황은 많지 않다
- 쿼리 튜닝의 주 목적은 꼭 필요한 데이터만 읽도록 개선하여 랜덤 I/O를 줄이는 것이다.

### 인덱스에 대해서 설명해주세요.

- 테이블의 모든 데이터를 검색해서 원하는 데이터를 찾기는 오래걸리는 일
- 더 빠른 검색을 도울 수 있는 자료 구조

### 인덱스의 동작 방식에 대해서 설명해주세요.

- 컬럼 값과 해당 레코드가 저장된 주소를 key-value로 삼아 인덱스를 생성함
- 더 세부적인 동작 방식은 어떤 알고리즘을 선택하냐에 따라 다름
- 일반적으로는 B-Tree 사용

### 어떤 기준으로 인덱스를 설정해야할까요?

- CUD에 비해 R 작업이 자주 일어나는 테이블
- 그 중에서도 어떤 R 작업이 자주 일어나느냐에 따라 인덱스 구성을 다르게 잡을 것 같다

### 테이블에 인덱스를 많이 설정하면 좋을까요?

- 항상 좋은 것은 아님
- CUD가 굉장히 자주 일어나는 테이블에 인덱스를 지나치게 많이 설정하면 오히려 성능 저하의 원인이 됨

### 커버링 인덱스(Covering index)에 대해서 설명해주세요.

- 원하는 데이터를 인덱스에서 모두 추출할 수 있는 인덱스 (ex: select id from temp_table where id = 1)
- 실제 데이터 블록에 접근하는 과정이 필요 없어짐

### 다중 컬럼 인덱스(Multi-column index, 복합 인덱스)에 대해서 설명해주세요.

- 2개 이상의 컬럼을 포함하는 인덱스

### B-Tree 인덱스와 B+Tree 인덱스에 대해 설명해주세요.

> B: Binary (x), Balanced (o)

- B-Tree
  - 이진 트리 구조와 비슷하지만, 이진은 아니고 한 노드가 여러 자식 노드를 가질 수 있음
  - 데이터가 정렬된 상태로 유지되어 있음
- B+Tree
  - B-Tree 의 확장개념
  - 리프 노드를 제외하고는 데이터를 담지 않음 -> 더 많은 메모리 확보 가능 -> 하나의 노드에 더 많은 Key 수용 가능

### Hash 인덱스에 대해서 설명해주세요.

- 컬럼의 값으로 해시값을 계산해 인덱싱하는 알고리즘
- 매우 빠른 검색을 지원
- 값을 변형해서 인덱싱하여 값의 일부나 범위를 통해 검색할 경우에는 사용이 불가
- 메모리 기반의 DB에서 많이 사용

### 클러스터링 인덱스에 대해서 설명해주세요.

- 클러스터링: 여러개를 하나로 묶는다
- InnoDB storage 엔진에서만 지원
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
- 프라이머리 키 값에 의해 레코드 저장 위치가 결정

### 인덱스 스캔 방식에 대해서 설명해주세요.

- 인덱스 레인지 스캔
  - B-Tree의 루트 페이지부터 리프페이지까지 내려가 범위 탐색의 시작점 찾기
  - 정렬된 인덱스 데이터를 범위 탐색 끝점까지 순서대로 읽기
- 인덱스 풀 스캔
  - 전체 인덱스 탐색
- 루스 인덱스 스캔
  - 인덱스 레인지 스캔과 유사하지만 중간중간 필요없는 인덱스 키 값을 건너뜀
  - group by와 집계함수 등에 최적화된 방식


### 쿼리 실행 계획에 대해서 설명해주세요. 실행 계획을 확인해본적이 있나요?

- 쿼리 실행 계획: DBMS가 쿼리를 처리하기 위해 사용하는 실행 계획
- MySQL을 기준으로 explain 키워드 이용
- 사용 경험
  - 어떤 쿼리에서 의도한 인덱스를 잘 타는지 확인
  - 복잡한 조건을 가진 쿼리에서 어떤 식으로 인덱스를 추가하는 것이 효율적인지 분석하기 위해
  - 이미 존재하는 테이블에 컬럼을 추가하였고, 그 컬럼이 조회 조건으로 자주 사용될 것이라고 예상될 때 어떤 식으로 인덱스를 추가하는 것이 효율적인지 분석하기 위해

### 힌트에 대해서 설명해주세요.

- 쿼리 실행 계획을 의도한대로 사용하도록 알려주는 주석

### 인덱스가 잘 동작하고 있는지 어떻게 확인할 수 있을까요?

- 쿼리 실행 계획을 확인한다 (explain)
- 테이블풀스캔을 하는지, 의도한 인덱스를 이용하는지 등의 정보를 확인할 수 있음

### 인덱스 사용시 주의해야할 점에 대해서 알려주세요.

> 🤔 질문의 의도가 인덱스 '생성'시 주의할 점이 아니라 '사용'시 주의할 점이 맞는가..?

- 인덱스를 저장하기 위한 공간이 따로 필요
- CUD 성능에 영향
- 인덱스를 추가한다고 무조건 적용되는 것은 아니고, 실행 계획을 통해 인덱스가 잘 타는지 점검 필요

### GROUP BY 사용시 인덱스가 걸리는 조건에 대해 설명해주세요.

- group by에 사용된 컬럼들이
  - 명시된 순서와 인덱스 컬럼의 순서가 일치해야 한다
  - 인덱스 컬럼의 뒤에 있는 컬럼이 group by에 명시되지 않아도 된다 (index:a,b,c -> group by a만 명시해도 인덱스 걸림)
  - group by에 포함된 컬럼은 인덱스에 존재해야한다

### 이름, 국가, 성별이 있는 테이블에서 인덱스를 어떻게 걸어야할까요?

- 좀더 구체적인 상황 설명이 필요. 해당 테이블로 조회 쿼리를 자주 실행하는지, 어떤 컬럼을 기준으로 자주 조회하는지 등
