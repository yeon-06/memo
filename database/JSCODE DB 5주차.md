### DB 세션에 대해서 설명해주세요.

- client가 DB에 연결되어있는 동안의 기간

### Commit에 대해서 설명해주세요.

- 트랜잭션 종료 시 해당 업데이트를 확정한다는 의미

### Rollback에 대해서 설명해주세요.

- 트랜잭션 처리 과정에서 예외가 발생하는 등 업데이트를 모두 취소 처리한다는 의미

### Auto Commit 설정에 대해서 설명해주세요.

- 각 SQL문이 자체적으로 단일 트랜잭션을 형성하도록 함
- auth commit이 비활성화되면, 트랜잭션에서 commit을 명시하지 않고 종료한 경우 MySQL이 해당 트랜잭션을 롤백.

### 트랜잭션에 대해 설명해주세요.

- 작업의 완전성을 보장해주는 것
- 논리적인 작업을 완벽하게 처리하거나, 처리하지 못한 경우에는 원 상태로 복구해 작업의 일부만 적용되는 현상이 발생하지 않도록, 데이터 정합성이 맞도록 해주는 기능

> (+) Lock과의 차이점?  
> 락: 동시성을 제어하기 위한 기능  
> 트랜잭션: 데이터의 정합성을 보장하는 기능

### 트랜잭션의 성질 ACID에 대해서 설명해주세요.

- Atomicity; 원자성: 트랜잭션의 연산이 모두 반영/모두 롤백
- Consistency; 일관성: 트랜잭션 처리 전후로 데이터에 모순이 없는 상태 유지 (무결성 제약을 위반하지 않는지 등)
- Isolation; 독립성: 서로 다른 트랜잭션이 서로의 연산 작업을 방해하지 못하도록
- Durability; 영속성: 성공적으로 수행된 트랜잭션은 영원히 반영

### 트랜잭션 격리 수준이 뭘까요?

- 여러 트랜잭션이 동시 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것

### 트랜잭션 격리 수준에 대해서 설명해주세요.

||READ UNCOMMITTIED|READ COMMITTIED|REPEATABLE READ|SERIALIZABLE|
|---|-|-|-|-|
|dirty read|o|x|x|x|
|non-repeatable read|o|o|x|x|
|phantom read|o|o|o(InnoDB는 x)|x|

- dirty read
  - 한 트랜잭션에서 처리된 작업이 아직 완료되지 않았는데도 다른 트랜잭션에서 조회되는 현상
- non-repeatable read
  - 한 트랜잭션에서 여러번 select한다고 가정할 때, 다른 트랜잭션의 커밋에 의해 한 트랜잭션에서 다른 select 조회 결과를 가져올 수 있는 현상
- phantom read

### DB 동시성 제어에 대해서 설명해주세요.

- 트랜잭션이 서로 간섭하지 않고 정확하게 실행되도록 보장하는 메커니즘

### 갱신 손실 문제에 대해 설명해주세요.

- = lost update
- 서로 다른 트랜잭션이 동시에 같은 데이터를 업데이트하는 경우 한 쪽의 업데이트가 손실하는 문제

### DB 락에 대해서 설명해주세요.

- 스토리지 엔진 레벨
  - 스토리지 엔진 간 상호 영향을 미치지 않는 락
  - 레코드 락: 레코드를 잠금
  - 갭락: 레코드와 레코드 사이의 간격 잠금
  - 넥스트 키 락: 레코드락 + 갭락
  - 자동 증가 락: auth_increment의 중복되지 않고 순차적으로 증가하는 일련번호 제공을 위해 테이블 수준의 잠금
- MySQL 엔진 레벨 (MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분)
  - 모든 스토리지 엔진에 영향을 주는 락
  - 글로벌 락: 글로벌 락이 걸리면 해제될 때까지 SELECT를 제외한 대부분의 DDL, DML이 대기 상태로 존재. 테이블이나 DB가 달라도 영향.
  - 테이블 락: 개별 테이블 단위로 설정되는 락
  - 네임드 락: 임의의 문자열에 대한 잠금 (테이블이나 레코드가 아니라 문자열에 대한 잠금임)
  - 메타데이터 락: DB의 테이블, 뷰 등의 이름이나 구조를 변경하는 경우 획득하는 락

> (+) InnoDB의 락  
> InnoDB는 레코드를 잠그는 것이 아니라 인덱스를 잠근다.
> 변경할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락으로 건다.
> 인덱스가 없다면? -> 테이블 풀스캔 -> 모든 레코드를 잠금

### DB 데드락에 대해서 설명해주세요.

- 서로 다른 트랜잭션을 동시에 처리하다 서로의 잠금을 포기하는 상황
- 데드락 경험
  - 어떤 데이터를 삭제하는 API가 따닥으로 호출됨. soft delete를 사용해서 JPA의 더티체킹에 의해 update문이 여러개 호출되는 상황
  - 원래 따닥 호출되면 안되는 API라 애플리케이션 로직 딴에서 동시성 처리가 되어있지 않았음. DB 데드락이 왜 발생했을까에 대한 근본적인 궁금증.
  - 처음에 상황만 보고 생각했던 부분: 데드락이 감지되면 innodb_lock_wait_timeout 옵션에 의해 어느정도 대기하다 락을 포기하는거겠지? 이 대기 시간이 길어져서 데드락이 발생한건 아닐까?
  - 실제 상황: innodb_deadlock_detect 옵션에 의해 데드락이 감지되면 바로 한 트랜잭션을 롤백하여 데드락을 해제 (롤백할 트랜잭션은 CUD되는 row의 수에 따라 결정) 대기 시간은 상관이 없으며 대기 시간으로 인해 오류가 발생하는 경우 timeout 로그가 발생
  - 실제 로그 확인: pk= 1,2에 대한 데이터를 처리해야한다고 가정. 한 트랜잭션에서 pk = 1에 대해 처리하고, pk=2에 대해 잠금 획득을 위해 대기중. 그와 동시에 다른 트랜잭션에서 pk=2에 대해 처리하고, pk=1에 대해 잠금 획득을 위해 대기중.인 상황이라서 데드락이 발생하였음.
  - (사담) CloudWatch에 데드락에 대한 로그들이 잘 남겨져있어서 다행이라고 생각... 로그의 중요성..

### DB 회복에 대해서 설명해주세요.

- 트랜잭션 수행 도중 장애로 인해 손상된 DB를 정상적인 상태로 복구시키는 방법
- 로그 회복 기법 (redo, undo)
  - redo: 트랜잭션 로그를 이용해 오류가 발생한 트랜잭션을 재실행하여 복구 수행
  - undo: 트랜잭션 로그를 이용해 오류와 관련된 모든 변경을 롤백하여 복구 수행
- 체크포인트 회복 기법
  - 로그 기록을 이용하되, 일정 시간 간격으로 체크포인트를 만들어둔다.
  - 장애가 발생하면 가장 최근 체크포인트 이후의 트랜잭션에 대해서 회복 작업을 수행
- 미디어 회복 기법
  - 전체 DB의 내용을 일정주기마다 다른 안전한 저장 장치에 복사해두는 덤프를 이용

### MySQL InnoDB의 기본 트랜잭션 고립 수준은 뭘까요?

- repeatable read
