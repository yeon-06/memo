> 솔직히 대부분의 내용이 이해가지 않는다.
> DB에 대한 기초 지식이 부족한 것 같다.
> 다른 CS 지식을 쌓고 다시 읽어야할 것 같다.

### 트랜잭션 vs 락

#### 트랜잭션

- 작업의 완전성 보장
- 논리적인 작업을 모두 완벽하게 처리하거나 완벽하게 원 상태로 복구시킴
- 데이터 정합성을 위한 기능

#### 락

- 동시성 제어를 위한 기능
- 여러 커넥션에서 동시에 동일한 자원을 요청하는 경우 방지

### 트랜잭션; Transaction

#### InnoDB vs MyISAM

`InnoDB`와 `MyISAM`에서 아래와 같은 쿼리를 실행했다고 가정해보자.

```sql
-- ID는 Primary Key로 중복되면 안된다.
INSERT INTO users (id) values (3);
INSERT INTO users (id) values (1),(2),(3);
```

3은 이미 저장한 값이므로 두번째 sql문에서 primary key 중복 오류가 난다.  
하지만 `MyISAM`에서는 1, 2를 이미 저장한 상태이므로 롤백시켜주지 않는다.

> `InnoDB`와 `MyISAM`은 `MySQL`을 위한 데이터베이스 엔진이다.    
> MySQL 5.5 이전 버전에서는 `MyISAM`을 사용하고 있다.

### 잠금; Lock

- `MySQL 엔진 레벨`
    - : MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분
    - 모든 스토리지 엔진에 영향
    - 여러 락 제공
        - `테이블 락`: 테이블 데이터 동기화를 위해
        - `유저 락`: 사용자의 필요에 맞게 사용하도록
        - `네임 락`: 테이블 명에 대한 잠금
- `스토리지 엔진 레벨`
    - 스토리지 엔진 간 상호 영향 X

#### 글로벌 락; Global Lock

- `FLUSH TABLES WITH READ LOCK` 명령으로만 획득 가능
- MySQL에서 제공하는 잠금 중 범위가 가장 큼
- MySQL 서버 전체에 영향 (DB나 테이블이 달라도 영향)

> `FLUSH TABLES WITH READ LOCK`  
> 실행과 동시에 MySQL 서버의 모든 테이블에 잠금.
> 이미 쓰기 잠금된 부분이 있다면 해당 부분의 잠금이 풀릴 때까지 대기.
> 최악의 경우 INSERT, UPDATE, DELETE 쿼리가 아주 오랜 시간 실행되지 못할 수 있으므로 웹 서비스용으로 사용하는 서버에서는 가급적 사용하지 않는게 좋음

#### 테이블 락; Table Lock

- 테이블 단위로 설정되는 잠금
- 명시적 테이블 락
    - `LOCK TABLES table_name [READ | WRITE]`
    - MyISAM뿐 아니라 InnoDB를 사용하는 테이블도 설정 ok
    - `UNLOCK TABLES`으로 잠금 해제 불가
    - 특별한 상황이 아닌 이상 거의 사용할 필요 X
    - 글로벌 락처럼 온라인 작업에 상당한 영향
- 묵시적 테이블 락
    - MyISAM 또는 MEMORY 테이블에 데이터 변경하는 쿼리 실행 시 발생
    - 데이터 변경 완료 시 즉시 잠금 해제
    - InnoDB의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금 제공
        - 단순 데이터 변경 쿼리로 인한 묵시적 테이블 락 설정 X
        - 스키마를 변경하는 쿼리에서는 락 설정 O

#### 유저 락; User Lock

- `GET_LOCK()` 함수로 임의 잠금 설정 가능
- 사용자가 지정한 문자열에 대해 획득하고 해제하는 잠금
- ex: DB서버 1대에 웹서버 5대 접근하는 경우 여러 클라이언트가 상호 동기화를 처리해야 한다면?
- 많은 레코드를 한 번에 변경하는 트랜잭션의 경우에 유용하게 사용 가능

#### 네임 락; Name Lock

- DB 객체(ex: 테이블, 뷰) 이름을 변경하는 경우 획득
- `RENAME TABLE table_a TO table_B`

#### MyISAM & MEMORY 스토리지 엔진 잠금

- 자체적인 잠금 X
- MySQL 엔진에서 제공하는 테이블 락 사용
- 쿼리 단위로 필요한 잠금을 한번에 모두 요청해서 획득 -> 데드락 X

#### InnoDB 스토리지 엔진 잠금

- MySQL의 잠금과 별도로 레코드 잠금 방식 탑재
- MuISAM보다 훨씬 뛰어난 동시성 처리
- MySQL 명령을 이용해 접근하기 힘듦
- `Optimistic locking` vs `Pessimistic locking`
    - O: 각 트랜잭션이 같은 레코드를 변경할 가능성이 적다고 가정. 변경 작업 수행하고 마지막에 잠금 충돌 있었는지 확인. 문제 있으면 롤백.
    - P: 현재 트랜잭션에서 변경하고자 하는 레코드에 대한 잠금 획득 -> 변경 -> 해제
- InnoDB는 비관적 잠금(Pessimistic locking) 사용

레코드 락

- 레코드 자체만 잠금
- InnoDB 스토리지 엔진은 레코드 자체가 아닌 인덱스의 레코드 잠금
- 인덱스가 없어도 내부적으로 자동 생성된 클러스터 인덱스 사용

갭 락

- 레코드와 인접한 레코드 사이의 간격만 잠금
- 레코드 - 레코드 사이의 간격에 새로운 레코드 생성을 제어
- 자체적인 사용 X. 넥스트 키 락의 일부로 사용.

넥스트 키 락

- 레코드 락 + 갭 락
- REPEATABLE READ 격리 수준을 사용해야 함
- innodb_locks_unsafe_for_binlog 파라미터 비활성화 시 변경을 위해 검색하는 레코드에 넥스트 키 락 잠금
- 목적: 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 낸 결과와 동일하게 만들도록 보장

자동 증가 락

- 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT 속성 제공
- 중복되지 않고 저장된 순서대로 증가한 일련번호 값을 갖게 해줌
- InnoDB 스토리지 엔진에서는 내부적으로 테이블 수준의 잠금인 AUTO_INCREMENT 락 제공
